The (async event-loop) module has the follow procedures:


  (make-event-loop)

This constructs a new event loop object.


  (event-loop? obj)

This procedure indicates whether 'obj' is an event-loop object
constructed by make-event-loop.


  (event-loop-run! loop)

This starts the event loop, which runs in the thread which calls this
procedure.  Where event-loop-quit! has been called, this procedure may
be called again to restart the same event loop.


  (event-loop-add-read-watch! loop file proc)

The 'proc' callback should take a single argument, and when called
this will be set to 'in or 'excpt.  The same port or file descriptor
can also be passed to event-loop-add-write-watch, and if so and the
descriptor is also available for writing, the write callback will also
be called with its argument set to 'out.  If there is already a read
watch for the file passed, the old one will be replaced by the new
one.  If proc returns #f, the read watch (and any write watch for the
same file) will be removed from the event loop, otherwise the watch
will continue.  This is thread safe - any thread may add a watch, and
the callback will execute in the event loop thread.  The file argument
can be either a port or a file descriptor.  If 'file' is a file
descriptor, any port for the descriptor is not referenced for garbage
collection purposes - it must remain valid while operations are
carried out on the descriptor.  If 'file' is a buffered port,
buffering will be taken into account in indicating whether a read can
be made without blocking (but on a buffered port, for efficiency
purposes each read operation in response to this watch should usually
exhaust the buffer by looping on char-ready?).


  (event-loop-add-write-watch! loop file proc)

The 'proc' callback should take a single argument, and when called
this will be set to 'out or 'excpt.  The same port or file descriptor
can also be passed to event-loop-add-read-watch, and if so and the
descriptor is also available for reading or in error, the read
callback will also be called with its argument set to 'in or 'excpt
(if both a read and a write watch have been set for the same file
argument, and there is an exceptional condition, it is the read watch
procedure which will be called with 'excpt rather than the write watch
procedure).  If there is already a write watch for the file passed,
the old one will be replaced by the new one.  If proc returns #f, the
write watch (and any read watch for the same file) will be removed
from the event loop, otherwise the watch will continue.  This is
thread safe - any thread may add a watch, and the callback will
execute in the event loop thread.  The file argument can be either a
port or a file descriptor.  If 'file' is a file descriptor, any port
for the descriptor is not referenced for garbage collection purposes -
it must remain valid while operations are carried out on the
descriptor.  If 'file' is a buffered port, buffering will be taken
into account in indicating whether a write can be made without
blocking.


  (event-loop-remove-watch! loop file)

The file argument may be a port or a file descriptor, and this removes
any read and write watch previously entered for that port or file
descriptor.  This is thread safe - any thread may remove a watch.  A
file descriptor and a port with the same underlying file descriptor
compare equal for the purposes of removal.


  (event-post! loop action)

The 'action' callback is a thunk.  This is thread safe - any thread
may post an event (that is its main purpose), and the action callback
will execute in the event loop thread.  Actions execute in the order
in which they were posted.  If an event is posted from a worker
thread, it will normally be necessary to call event-loop-block!
beforehand.


  (timeout-post! loop msecs action)

This adds a timeout to the event loop.  The timeout will repeat unless
and until the passed-in callback returns #f or timeout-remove! is
called.  The passed-in callback must be a thunk.  This procedure
returns a tag symbol to which timeout-remove! can be applied.  It may
be called by any thread.


  (timeout-remove! loop tag)

This stops the timeout with the given tag from executing in the event
loop concerned.  It may be called by any thread.


  (event-loop-block! loop val)

By default, upon there being no more watches, timeouts and posted
events for an event loop, event-loop-run! will return, which is
normally what you want with a single threaded program.  However, this
is undesirable where a worker thread is intended to post an event to
the main loop after it has reached a result, say via
a-sync-run-task-in-thread, because the main loop may have ended before
it posts.  Passing #t to the val argument of this procedure will
prevent that from happening, so that the event loop can only be ended
by calling event-loop-quit!.  To switch it back to non-blocking mode,
pass #f.  This is thread safe - any thread may call this procedure.


  (event-loop-quit! loop)

Causes the event loop to unblock.  Any events remaining in the event
loop will be discarded.  New events may subsequently be added after
event-loop-run! has unblocked and event-loop-run! then called for
them.  This is thread safe - any thread may call this procedure.


  (a-sync-run-task-in-thread! loop resume thunk)

This is a convenience procedure which will run 'thunk' in its own
thread, and then post an event to the event loop specified by the
'loop' argument which applies 'resume' (obtained from a call to
a-sync) to the thunk's return value.  It is intended to be called in a
waitable procedure invoked by a-sync.  It will normally be necessary
to call event-loop-block! before invoking this procedure.


  (a-sync-run-task! loop resume thunk)

This is a convenience procedure for use with an event loop, which will
run 'thunk' in the event loop specified by the 'loop' argument, and
apply 'resume' (obtained from a call to a-sync) to thunk's return
value.  It is intended to be called in a waitable procedure invoked by
a-sync.  It is the single-threaded corollary of
a-sync-run-task-in-thread!.  This means that (unlike with
a-sync-run-task-in-thread!) while the task is running other events in
the event loop will not make progress.  This is not particularly
useful except when called by the event loop thread for the purpose of
bringing the event loop to an end at its own place in the event queue,
or when called by a worker thread to report a result expected by a
waitable procedure running in the event loop thread.  (For the latter
case though, a-sync-run-task-in-thread! is generally a more convenient
wrapper.)


  (a-sync-read-watch! loop file resume proc)

This is a convenience procedure for use with an event loop, which will
run 'proc' in the event loop thread whenever 'file' is ready for
reading, and apply resume (obtained from a call to a-sync) to the
return value of 'proc'.  'proc' should take a single argument which
will be set by the event loop to 'in or 'excpt (see the documentation
on event-loop-add-read-watch! for further details).  It is intended to
be called in a waitable procedure invoked by a-sync.  The watch is
multi-shot - it is for the user to bring it to an end at the right
time by calling event-loop-remove-watch! in the waitable procedure.


  (a-sync-read-watch-once! loop file resume proc)

This is a convenience procedure for use with an event loop, which will
run 'proc' in the event loop thread whenever 'file' is ready for
reading, and apply resume (obtained from a call to a-sync) to the
return value of 'proc'.  'proc' should take a single argument which
will be set by the event loop to 'in or 'excpt (see the documentation
on event-loop-add-read-watch! for further details).  It is intended to
be called in a waitable procedure invoked by a-sync.  The watch is
single shot only - as soon as 'proc' has run once and completed, the
watch will be removed from the event loop.  Note that once 'proc' has
returned, if there is a write watch for 'file' that will also be
removed.



  (a-sync-write-watch! loop file resume proc)

This is a convenience procedure for use with an event loop, which will
run 'proc' in the event loop thread whenever 'file' is ready for
writing, and apply resume (obtained from a call to a-sync) to the
return value of 'proc'.  'proc' should take a single argument which
will be set by the event loop to 'out or 'excpt (see the documentation
on event-loop-add-write-watch! for further details).  It is intended
to be called in a waitable procedure invoked by a-sync.  The watch is
multi-shot - it is for the user to bring it to an end at the right
time by calling event-loop-remove-watch! in the waitable procedure.


  (a-sync-write-watch-once! loop file resume proc)

This is a convenience procedure for use with an event loop, which will
run 'proc' in the event loop thread whenever 'file' is ready for
writing, and apply resume (obtained from a call to a-sync) to the
return value of 'proc'.  'proc' should take a single argument which
will be set by the event loop to 'out or 'excpt (see the documentation
on event-loop-add-write-watch! for further details).  It is intended
to be called in a waitable procedure invoked by a-sync.  The watch is
single shot only - as soon as 'proc' has run once and completed, the
watch will be removed from the event loop.  Note that once 'proc' has
returned, if there is a read watch for 'file' that will also be
removed.


  (a-sync-timeout! loop msec resume thunk)

This is a convenience procedure for use with an event loop, which will
run 'thunk' in the event loop thread whenever the timeout expires, and
apply resume (obtained from a call to a-sync) to the return value of
'thunk'.  It is intended to be called in a waitable procedure invoked
by a-sync in the coroutines module.  The timeout is multi-shot - it is
for the user to bring it to an end at the right time by applying
timeout-remove! in the waitable procedure to the tag returned by this
procedure.



  (a-sync-timeout-once! loop msec resume thunk)

This is a convenience procedure for use with an event loop, which will
run 'thunk' in the event loop thread when the timeout expires, and
apply resume (obtained from a call to a-sync) to the return value of
'thunk'.  It is intended to be called in a waitable procedure invoked
by a-sync.  The timeout is single shot only - as soon as 'thunk' has
run once and completed, the timeout will be removed from the event
loop.


----------------------------------------


In addition, (a-sync event-loop) loads the (a-sync monotonic-time)
module, which provides two procedures:


(have-monotonic-time)

This procedure indicates whether the get-time procedure (see below)
provides a monotonic clock.  Almost all modern linux/unix-like systems
will do so.  This procedure may return #f if windows is in use, or if
the guile-a-sync library was cross-compiled on one architecture for a
different one.


(get-time)

This returns the current time as a (secs . usecs) pair from some
arbitrary epoch.  If (have-monotonic-time) returns #t, then this will
be derived from a monotonic clock obtained by applying CLOCK_MONOTONIC
to the clock_gettime() POSIX function.  This procedure is used by the
event-loop timeout implementation.
