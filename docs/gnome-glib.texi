@node gnome glib,compose,monotonic time,Top

When using the scheme (gnome gtk) bindings of guile-gnome with guile,
in order to provide await semantics on gtk+ callbacks it will normally
be necessary to use the 'await' and 'resume' procedures provided by
the a-sync procedure in the @ref{coroutines,,(a-sync coroutines)}
module directly (calling 'resume' in the gtk+ callback when ready, and
waiting on that callback using 'await').  However when launching
timeouts, file watches or idle events on the glib main loop,
convenience procedures are possible similar to those provided for the
event loop in the @ref{event loop,,(a-sync event-loop)} module.  These
are set out below.

Note that the g-idle-add procedure in guile-gnome is suspect - there
appears to be a garbage collection issue, and if you call the
procedure often enough in a single or multi-threaded program it will
eventually segfault.  g-io-add-watch is also broken in guile-gnome, so
this library uses its own glib-add-watch procedure which is exported
publicly in case it is useful to users.

All the other scheme files provided by this library are by default
compiled by this library to bytecode.  That is not the case with this
module, so as not to create a hard dependency on guile-gnome.

The (a-sync gnome-glib) module provides the following procedures:

@deffn {Scheme Procedure} await-glib-task-in-thread await resume thunk [handler]
This is a convenience procedure which will run 'thunk' in its own
thread, and then post an event to the default glib main loop when
'thunk' has finished.  This procedure calls 'await' and will return
the thunk's return value.  It is intended to be called in a waitable
procedure invoked by a-sync.  If the optional 'handler' argument is
provided, then it will be run in the event loop thread if 'thunk'
throws and its return value will be the return value of this
procedure; otherwise the program will terminate if an unhandled
exception propagates out of 'thunk'.  'handler' should take the same
arguments as a guile catch handler (this is implemented using catch).

This procedure must (like the a-sync procedure) be called in the same
thread as that in which the default glib main loop runs, where the
result of calling 'thunk' will be received.  As mentioned above, the
thunk itself will run in its own thread.

Exceptions may propagate out of this procedure if they arise while
setting up (that is, before the worker thread starts), which shouldn't
happen unless memory is exhausted or pthread has run out of resources.
Exceptions arising during execution of the task, if not caught by a
handler procedure, will terminate the program.  Exceptions thrown by
the handler procedure will propagate out of g-main-loop-run.

This procedure uses g-idle-add: see the introductory remarks about
that.

Here is an example of the use of await-glib-task-in-thread:
@example
(define main-loop (g-main-loop-new #f #f))
(a-sync (lambda (await resume)
	  (simple-format #t "1 + 1 is ~A\n"
			 (await-glib-task-in-thread await resume
						    (lambda ()
						      (+ 1 1))))
	  (g-main-loop-quit main-loop)))
(g-main-loop-run main-loop)
@end example
@end deffn

@deffn {Scheme Procedure} await-glib-task await resume thunk
This is a convenience procedure for use with glib, which will run
'thunk' in the default glib main loop.  This procedure calls 'await'
and will return the thunk's return value.  It is intended to be called
in a waitable procedure invoked by a-sync.  It is the single-threaded
corollary of await-glib-task-in-thread.  This means that (unlike with
await-glib-task-in-thread) while 'thunk' is running other events in
the main loop will not make progress.  This is not particularly useful
except, say, when called by the main loop thread for the purpose of
bringing the loop to an end at its own place in the event queue, or
for co-operative multi-tasking, say by composing tasks with
compose-a-sync (see the @ref{compose,,(a-sync compose)} module).

This procedure must (like the a-sync procedure) be called in the same
thread as that in which the default glib main loop runs.

Exceptions may propagate out of this procedure if they arise while
setting up (that is, before the task starts), which shouldn't happen
unless memory is exhausted.  Exceptions arising during execution of
the task, if not caught locally, will propagate out of
g-main-loop-run.

This procedure uses g-idle-add: see the introductory remarks about
that.

Here is an example of the use of await-glib-task:
@example
(define main-loop (g-main-loop-new #f #f))
(a-sync (lambda (await resume)
	  (simple-format #t "1 + 1 is ~A\n"
			 (await-glib-task await resume
					  (lambda ()
					    (+ 1 1))))
	  (g-main-loop-quit main-loop)))
(g-main-loop-run main-loop)
@end example
@end deffn

@deffn {Scheme Procedure} await-glib-timeout await resume msecs thunk
This is a convenience procedure for use with a glib main loop, which
will run 'thunk' in the default glib main loop when the timeout
expires.  This procedure calls 'await' and will return the thunk's
return value.  It is intended to be called in a waitable procedure
invoked by a-sync.  The timeout is single shot only - as soon as
'thunk' has run once and completed, the timeout will be removed from
the event loop.

This procedure must (like the a-sync procedure) be called in the same
thread as that in which the default glib main loop runs.

Exceptions may propagate out of this procedure if they arise while
setting up (that is, before the first call to 'await' is made), which
shouldn't happen unless memory is exhausted.  Exceptions thrown by
'thunk', if not caught locally, will propagate out of g-main-loop-run.

Here is an example of the use of await-glib-timeout:
@example
(define main-loop (g-main-loop-new #f #f))
(a-sync (lambda (await resume)
	  (simple-format #t
			 "Timeout ~A\n"
			 (await-glib-timeout await resume
					     100
					     (lambda ()
					       "expired")))
	  (g-main-loop-quit main-loop)))
(g-main-loop-run main-loop)
@end example
@end deffn

@deffn {Scheme Procedure} glib-add-watch ioc cond func [context]
This procedure replaces guile-gnome's g-io-add-watch procedure, which
won't compile.  It attaches a watch on a g-io-channel object to the
main context provided, or if none is provided, to the default glib
main context (the main program loop).  It returns a glib ID which can
be passed subsequently to the g-source-remove procedure.  It should be
possible to call this procedure in any thread.

See the documentation on the a-sync-glib-read-watch procedure for
some of the difficulties with using g-io-channel watches with
guile-gnome.
@end deffn

@deffn {Scheme Procedure} a-sync-glib-read-watch resume fd proc
This is a convenience procedure for use with a glib main loop, which
will run 'proc' in the default glib main loop whenever the file
descriptor 'fd' is ready for reading, and apply resume (obtained from
a call to a-sync) to the return value of 'proc'.  'proc' should take
two arguments, the first of which will be set by glib to the
g-io-channel object constructed for the watch and the second of which
will be set to the GIOCondition ('in, 'hup or 'err) provided by glib
which caused the watch to activate.  It is intended to be called in a
waitable procedure invoked by a-sync.  The watch is multi-shot - it is
for the user to bring it to an end at the right time by calling
g-source-remove in the waitable procedure on the id tag returned by
this procedure.  Any port for the file descriptor 'fd' is not
referenced for garbage collection purposes - it must remain valid
while the read watch is active.  This procedure is mainly intended as
something from which higher-level asynchronous file operations can be
constructed, such as the await-glib-getline procedure.

File watches in guile-gnome are implemented using a GIOChannel object,
and unfortunately GIOChannel support in guile-gnome is decaying.  The
only procedure that guile-gnome provides to read from a GIOChannel
object is g-io-channel-read-line, which does not work.  One is
therefore usually left with having to read from a guile port (whose
underlying file descriptor is 'fd') using guile's port input
procedures, but this has its own difficulties because either the port
has to be unbuffered (say by using the R6RS open-file-input-port
procedure with a buffer-mode of none), or 'proc' must deal with
everything in the port's buffer by looping on char-ready? before
returning.  This is because if the port is buffered, once the port is
read from there may be further characters in the buffer to be dealt
with even though the GIOChannel watch does not trigger because there
is nothing new to make the file descriptor ready for reading.

Because this procedure takes a 'resume' argument derived from the
a-sync procedure, it must (like the a-sync procedure) in practice be
called in the same thread as that in which the default glib main loop
runs.

This procedure should not throw an exception unless memory is
exhausted, or guile-glib throws for some other reason.  If 'proc'
throws, say because of port errors, and the exception is not caught
locally, it will propagate out of g-main-loop-run.

As an example of how to use a-sync-glib-read-watch, here is the
implementation of await-glib-getline:
@example
(define (await-glib-getline await resume port)
  (define chunk-size 128)
  (define text (make-string chunk-size))
  (define text-len 0)
  (define (append-char! ch)
    (when (and (= (modulo text-len chunk-size) 0)
	       (> text-len 0))
      (let ((tmp text))
	(set! text (make-string (+ text-len chunk-size)))
	(string-copy! text 0 tmp)))
    (string-set! text text-len ch)
    (set! text-len (1+ text-len)))
  (define id (a-sync-glib-read-watch resume
				     (port->fdes port)
				     (lambda (ioc status)
				       (let next ()
					 (let ((ch (read-char port)))
					   (cond
					    ((eof-object? ch)
					     (if (= text-len 0)
						 ch
						 (substring/shared text 0 text-len)))
					    ((char=? ch #\newline)
					     (substring/shared text 0 text-len))
					    (else
					     (append-char! ch)
					     (if (char-ready? port)
						 (next)
						 'more))))))))
  (let next ((res (await)))
    (if (eq? res 'more)
	(next (await))
	(begin
	  (g-source-remove id)
	  (release-port-handle port)
	  res))))
@end example
@end deffn

@deffn {Scheme Procedure} await-glib-getline await resume port
This is a convenience procedure for use with a glib main loop, which
will start a read watch on 'port' for a line of input.  It calls
'await' while waiting for input and will return the line of text
received (without the terminating '\n' character).  The event loop
will not be blocked by this procedure even if only individual
characters are available at any one time.  It is intended to be called
in a waitable procedure invoked by a-sync, and this procedure is
implemented using a-sync-glib-read-watch.  If an end-of-file object is
encountered which terminates a line of text, a string containing the
line of text will be returned (and from version 0.3, if an end-of-file
object is encountered without any text, the end-of-file object is
returned rather than an empty string).

For the reasons explained in the documentation on
a-sync-glib-read-watch, this procedure only works correctly if the
port passed to the 'port' argument has buffering switched off, say by
using the R6RS open-file-input-port procedure with a buffer-mode of
none.  This makes the procedure less useful than would otherwise be
the case.

This procedure must (like the a-sync procedure) be called in the same
thread as that in which the default glib main loop runs.

Exceptions may propagate out of this procedure if they arise while
setting up (that is, before the first call to 'await' is made), which
shouldn't happen unless memory is exhausted.  Subsequent exceptions
(say, because of port errors) will propagate out of g-main-loop-run.

Here is an example of the use of await-glib-getline:
@example
(define main-loop (g-main-loop-new #f #f))
(a-sync (lambda (await resume)
          (display "Enter a line of text at the keyboard\n")
          (simple-format #t
                         "The line was: ~A\n"
                         (await-glib-getline await resume
					     (open-file-input-port "/dev/tty" (file-options) (buffer-mode none))))
	  (g-main-loop-quit main-loop)))
(g-main-loop-run main-loop)
@end example
@end deffn

@deffn {Scheme Procedure} a-sync-glib-write-watch resume fd proc
This is a convenience procedure for use with a glib main loop, which
will run 'proc' in the default glib main loop whenever the file
descriptor 'fd' is ready for writing, and apply resume (obtained from
a call to a-sync) to the return value of 'proc'.  'proc' should take
two arguments, the first of which will be set by glib to the
g-io-channel object constructed for the watch and the second of which
will be set to the GIOCondition ('out or 'err) provided by glib which
caused the watch to activate.  It is intended to be called in a
waitable procedure invoked by a-sync.  The watch is multi-shot - it is
for the user to bring it to an end at the right time by calling
g-source-remove in the waitable procedure on the id tag returned by
this procedure.  Any port for the file descriptor 'fd' is not
referenced for garbage collection purposes - it must remain valid
while the read watch is active.  This procedure is mainly intended as
something from which higher-level asynchronous file operations can be
constructed.

The documentation on the a-sync-glib-read-watch procedure comments
about about the difficulties of using GIOChannel file watches with
buffered ports.  The difficulties are not quite so intense with write
watches, but users are likely to get best results by using unbuffered
output ports (say by using the R6RS open-file-output-port procedure
with a buffer-mode of none).

Because this procedure takes a 'resume' argument derived from the
a-sync procedure, it must (like the a-sync procedure) in practice be
called in the same thread as that in which the default glib main loop
runs.

This procedure should not throw an exception unless memory is
exhausted, or guile-glib throws for some other reason.  If 'proc'
throws, say because of port errors, and the exception is not caught
locally, it will propagate out of g-main-loop-run.
@end deffn
