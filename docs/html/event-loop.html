<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>guile-a-sync: event loop</title>

<meta name="description" content="guile-a-sync: event loop">
<meta name="keywords" content="guile-a-sync: event loop">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="index.html#Top" rel="up" title="Top">
<link href="monotonic-time.html#monotonic-time" rel="next" title="monotonic time">
<link href="coroutines.html#coroutines" rel="prev" title="coroutines">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<a name="event-loop"></a>
<div class="header">
<p>
Next: <a href="monotonic-time.html#monotonic-time" accesskey="n" rel="next">monotonic time</a>, Previous: <a href="coroutines.html#coroutines" accesskey="p" rel="prev">coroutines</a>, Up: <a href="index.html#Top" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>
<hr>
<h4 class="node-heading">event loop</h4>

<p>The (a-sync event-loop) module provides an event loop for asynchronous
operations.  The event loop does not of itself start any new threads.
Instead it runs in the thread which calls event-loop-run!: that
procedure will block while there are events to be processed.  In most
programs the event loop will run in the main program thread, with
which the program began.  Many programs using event loops are entirely
single threaded.
</p>
<p>However, the event loop provided by this module does support multiple
threads.  Most of the event loop procedures in this module are thread
safe and may be called in any thread.  The thread safe procedures are
event-loop-run!  (as mentioned, this will cause the event loop to run
in the thread which calls it), event-loop-block!, event-loop-quit!,
event-post!, event-loop-add-read-watch!, event-loop-add-write-watch!,
event-loop-remove-read-watch!, event-loop-remove-write-watch!,
timeout-post! and timeout-remove!.  In particular, event-post! allows
worker threads to post an event to an event loop, say with the result
of a computation, so that the event callback will execute in the event
loop thread.
</p>
<p>This modules provides the following procedures:
</p>
<dl>
<dt><a name="index-set_002ddefault_002devent_002dloop_0021"></a>Scheme Procedure: <strong>set-default-event-loop!</strong> <em>[loop]</em></dt>
<dd><p>The &rsquo;loop&rsquo; (event loop) argument is optional.  This procedure sets the
default event loop for the procedures in this module to the one passed
in (which must have been constructed by the make-event-loop
procedure), or if no argument is passed (or #f is passed), a new event
loop will be constructed for you as the default, which can be accessed
via the get-default-event-loop procedure.  The default loop variable
is not a fluid or a parameter - it is intended that the default event
loop is the same for every thread in the program, and that the default
event loop would normally run in the thread with which the program
started.  This procedure is not thread safe - if it might be called by
a different thread from others which might access the default event
loop, then external synchronization may be required.  However, that
should not normally be an issue.  The normal course would be to call
this procedure once only on program start up as soon as the main
program event loop has been constructed, before other threads have
started.  It is usually a mistake to call this procedure twice: if
there are asynchronous events pending (that is, if event-loop-run!
has not returned) you will probably not get the results you expect.
</p></dd></dl>

<dl>
<dt><a name="index-get_002ddefault_002devent_002dloop"></a>Scheme Procedure: <strong>get-default-event-loop</strong></dt>
<dd><p>This returns the default loop set by the set-default-event-loop!
procedure, or #f if none has been set.
</p></dd></dl>

<dl>
<dt><a name="index-make_002devent_002dloop"></a>Scheme Procedure: <strong>make-event-loop</strong></dt>
<dd><p>This constructs a new event loop object.
</p></dd></dl>

<dl>
<dt><a name="index-event_002dloop_003f"></a>Scheme Procedure: <strong>event-loop?</strong> <em>obj</em></dt>
<dd><p>This procedure indicates whether &rsquo;obj&rsquo; is an event-loop object
constructed by make-event-loop.
</p></dd></dl>

<dl>
<dt><a name="index-event_002dloop_002drun_0021"></a>Scheme Procedure: <strong>event-loop-run!</strong> <em>[loop]</em></dt>
<dd><p>The &rsquo;loop&rsquo; (event loop) argument is optional.  This procedure starts
the event loop passed in as an argument, or if none is passed (or #f
is passed) it starts the default event loop.  The event loop will run
in the thread which calls this procedure.  If this procedure has
returned, including after a call to event-loop-quit!, this procedure
may be called again to restart the event loop.  If a callback throws,
or something else throws in the implementation, then this procedure
will return and it will be as if event-loop-quit! had been called.
</p></dd></dl>

<dl>
<dt><a name="index-event_002dloop_002dadd_002dread_002dwatch_0021"></a>Scheme Procedure: <strong>event-loop-add-read-watch!</strong> <em>file proc [loop]</em></dt>
<dd><p>The &rsquo;loop&rsquo; (event loop) argument is optional.  This procedure will
start a read watch in the event loop passed in as an argument, or if
none is passed (or #f is passed), in the default event loop.  The
&rsquo;proc&rsquo; callback should take a single argument, and when called this
will be set to &rsquo;in or &rsquo;excpt.  The same port or file descriptor can
also be passed to event-loop-add-write-watch, and if so and the
descriptor is also available for writing, the write callback will also
be called with its argument set to &rsquo;out.  If there is already a read
watch for the file passed, the old one will be replaced by the new
one.  If proc returns #f, the read watch will be removed from the
event loop, otherwise the watch will continue.  This is thread safe -
any thread may add a watch, and the callback will execute in the event
loop thread.  The file argument can be either a port or a file
descriptor.  If &rsquo;file&rsquo; is a file descriptor, any port for the
descriptor is not referenced for garbage collection purposes - it must
remain valid while operations are carried out on the descriptor.  If
&rsquo;file&rsquo; is a buffered port, buffering will be taken into account in
indicating whether a read can be made without blocking (but on a
buffered port, for efficiency purposes each read operation in response
to this watch should usually exhaust the buffer by looping on
char-ready?).
</p></dd></dl>

<dl>
<dt><a name="index-event_002dloop_002dadd_002dwrite_002dwatch_0021"></a>Scheme Procedure: <strong>event-loop-add-write-watch!</strong> <em>file proc [loop]</em></dt>
<dd><p>The &rsquo;loop&rsquo; (event loop) argument is optional.  This procedure will
start a write watch in the event loop passed in as an argument, or if
none is passed (or #f is passed), in the default event loop.  The
&rsquo;proc&rsquo; callback should take a single argument, and when called this
will be set to &rsquo;out or &rsquo;excpt.  The same port or file descriptor can
also be passed to event-loop-add-read-watch, and if so and the
descriptor is also available for reading or in exceptional condition,
the read callback will also be called with its argument set to &rsquo;in or
&rsquo;excpt (if both a read and a write watch have been set for the same
file argument, and there is an exceptional condition, it is the read
watch procedure which will be called with &rsquo;excpt rather than the write
watch procedure, so if that procedure returns #f only the read watch
will be removed).  If there is already a write watch for the file
passed, the old one will be replaced by the new one.  If proc returns
#f, the write watch will be removed from the event loop, otherwise the
watch will continue.  This is thread safe - any thread may add a
watch, and the callback will execute in the event loop thread.  The
file argument can be either a port or a file descriptor.  If &rsquo;file&rsquo; is
a file descriptor, any port for the descriptor is not referenced for
garbage collection purposes - it must remain valid while operations
are carried out on the descriptor.  If &rsquo;file&rsquo; is a buffered port,
buffering will be taken into account in indicating whether a write can
be made without blocking.
</p></dd></dl>

<dl>
<dt><a name="index-event_002dloop_002dremove_002dread_002dwatch_0021"></a>Scheme Procedure: <strong>event-loop-remove-read-watch!</strong> <em>file [loop]</em></dt>
<dd><p>The &rsquo;loop&rsquo; (event loop) argument is optional.  This procedure will
remove a read watch from the event loop passed in as an argument, or
if none is passed (or #f is passed), from the default event loop.  The
file argument may be a port or a file descriptor.  This is thread safe
- any thread may remove a watch.  A file descriptor and a port with
the same underlying file descriptor compare equal for the purposes of
removal.
</p></dd></dl>

<dl>
<dt><a name="index-event_002dloop_002dremove_002dwrite_002dwatch_0021"></a>Scheme Procedure: <strong>event-loop-remove-write-watch!</strong> <em>file [loop]</em></dt>
<dd><p>The &rsquo;loop&rsquo; (event loop) argument is optional.  This procedure will
remove a write watch from the event loop passed in as an argument, or
if none is passed (or #f is passed), from the default event loop.  The
file argument may be a port or a file descriptor.  This is thread safe
- any thread may remove a watch.  A file descriptor and a port with
the same underlying file descriptor compare equal for the purposes of
removal.
</p></dd></dl>

<dl>
<dt><a name="index-event_002dpost_0021"></a>Scheme Procedure: <strong>event-post!</strong> <em>action [loop]</em></dt>
<dd><p>The &rsquo;loop&rsquo; (event loop) argument is optional.  This procedure will
post a callback for execution in the event loop passed in as an
argument, or if none is passed (or #f is passed), in the default event
loop.  The &rsquo;action&rsquo; callback is a thunk.  This is thread safe - any
thread may post an event (that is its main purpose), and the action
callback will execute in the event loop thread.  Actions execute in
the order in which they were posted.  If an event is posted from a
worker thread, it will normally be necessary to call event-loop-block!
beforehand.
</p></dd></dl>

<dl>
<dt><a name="index-timeout_002dpost_0021"></a>Scheme Procedure: <strong>timeout-post!</strong> <em>msecs action [loop]</em></dt>
<dd><p>The &rsquo;loop&rsquo; (event loop) argument is optional.  This procedure adds a
timeout to the event loop passed in as an argument, or if none is
passed (or #f is passed), to the default event loop.  The timeout will
repeat unless and until the passed-in callback returns #f or
timeout-remove! is called.  The passed-in callback must be a thunk.
This procedure returns a tag symbol to which timeout-remove! can be
applied.  It may be called by any thread, and the timeout callback
will execute in the event loop thread.
</p></dd></dl>


<dl>
<dt><a name="index-timeout_002dremove_0021"></a>Scheme Procedure: <strong>timeout-remove!</strong> <em>tag [loop]</em></dt>
<dd><p>The &rsquo;loop&rsquo; (event loop) argument is optional.  This procedure stops
the timeout with the given tag from executing in the event loop passed
in as an argument, or if none is passed (or #f is passed), in the
default event loop.  It may be called by any thread.
</p></dd></dl>

<dl>
<dt><a name="index-event_002dloop_002dblock_0021"></a>Scheme Procedure: <strong>event-loop-block!</strong> <em>val [loop]</em></dt>
<dd><p>By default, upon there being no more watches, timeouts and posted
events for an event loop, event-loop-run! will return, which is
normally what you want with a single threaded program.  However, this
is undesirable where a worker thread is intended to post an event to
the main loop after it has reached a result, say via
await-task-in-thread!, because the main loop may have ended before it
posts.  Passing #t to the val argument of this procedure will prevent
that from happening, so that the event loop can only be ended by
calling event-loop-quit!.  To switch it back to non-blocking mode,
pass #f.  This is thread safe - any thread may call this
procedure.  The &rsquo;loop&rsquo; (event loop) argument is optional: this
procedure operates on the event loop passed in as an argument, or if
none is passed (or #f is passed), on the default event loop.
</p></dd></dl>

<dl>
<dt><a name="index-event_002dloop_002dquit_0021"></a>Scheme Procedure: <strong>event-loop-quit!</strong> <em>[loop]</em></dt>
<dd><p>This procedure causes an event loop to unblock.  Any events remaining
in the event loop will be discarded.  New events may subsequently be
added after event-loop-run! has unblocked and event-loop-run! then
called for them.  This is thread safe - any thread may call this
procedure.  The &rsquo;loop&rsquo; (event loop) argument is optional: this
procedure operates on the event loop passed in as an argument, or if
none is passed (or #f is passed), on the default event loop.
</p></dd></dl>

<dl>
<dt><a name="index-await_002dtask_002din_002dthread_0021"></a>Scheme Procedure: <strong>await-task-in-thread!</strong> <em>await resume [loop] thunk [handler]</em></dt>
<dd><p>The loop and handler arguments are optional.  The procedure will run
&rsquo;thunk&rsquo; in its own thread, and then post an event to the event loop
specified by the &rsquo;loop&rsquo; argument when &rsquo;thunk&rsquo; has finished, or to the
default event loop if no &rsquo;loop&rsquo; argument is provided or if #f is
provided as the &rsquo;loop&rsquo; argument (pattern matching is used to detect
the type of the third argument).  This procedure calls &rsquo;await&rsquo; and
will return the thunk&rsquo;s return value.  It is intended to be called in
a waitable procedure invoked by a-sync.  It will normally be necessary
to call event-loop-block! before invoking this procedure.  If the
optional &rsquo;handler&rsquo; argument is provided, then that handler will be run
in the event loop thread if &rsquo;thunk&rsquo; throws and the return value of the
handler would become the return value of this procedure; otherwise the
program will terminate if an unhandled exception propagates out of
&rsquo;thunk&rsquo;.  &rsquo;handler&rsquo; should take the same arguments as a guile catch
handler (this is implemented using catch).  If &rsquo;handler&rsquo; throws, the
exception will propagate out of event-loop-run!.
</p>
<p>This procedure must (like the a-sync procedure) be called in the same
thread as that in which the event loop runs, where the result of
calling &rsquo;thunk&rsquo; will be received.  As mentioned above, the thunk
itself will run in its own thread.
</p>
<p>Here is an example:
</p><div class="example">
<pre class="example">(set-default-event-loop!) ;; if none has yet been set
(a-sync (lambda (await resume)
	  (simple-format #t &quot;1 + 1 is ~A\n&quot;
			 (await-task-in-thread! await resume
						(lambda ()
						  (+ 1 1))))
	  (event-loop-quit!)))
(event-loop-block! #t) ;; because the task runs in another thread
(event-loop-run!)
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-await_002dtask_0021"></a>Scheme Procedure: <strong>await-task!</strong> <em>await resume [loop] thunk</em></dt>
<dd><p>The &rsquo;loop&rsquo; argument is optional.  This is a convenience procedure for
use with an event loop, which will run &rsquo;thunk&rsquo; in the event loop
specified by the &rsquo;loop&rsquo; argument, or in the default event loop if no
&rsquo;loop&rsquo; argument is provided or #f is provided as the &rsquo;loop&rsquo; argument.
This procedure calls &rsquo;await&rsquo; and will return the thunk&rsquo;s return value.
It is intended to be called in a waitable procedure invoked by a-sync.
It is the single-threaded corollary of await-task-in-thread!.  This
means that (unlike with await-task-in-thread!) while &rsquo;thunk&rsquo; is
running other events in the event loop will not make progress.  This
is not particularly useful except when called by the event loop thread
for the purpose of bringing the event loop to an end at its own place
in the event queue, or when called by a worker thread to report a
result expected by a waitable procedure running in the event loop
thread.  (For the latter case though, await-task-in-thread! is
generally a more convenient wrapper.)
</p>
<p>This procedure must (like the a-sync procedure) be called in the same
thread as that in which the event loop runs.
</p>
<p>Here is an example:
</p><div class="example">
<pre class="example">(set-default-event-loop!) ;; if none has yet been set
(a-sync (lambda (await resume)
	  (simple-format #t &quot;1 + 1 is ~A\n&quot;
			 (await-task! await resume
				      (lambda ()
					(+ 1 1))))))
(event-loop-run!)
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-await_002dtimeout_0021"></a>Scheme Procedure: <strong>await-timeout!</strong> <em>await resume [loop] msecs thunk</em></dt>
<dd><p>This is a convenience procedure for use with an event loop, which will
run &rsquo;thunk&rsquo; in the event loop thread when the timeout expires.  This
procedure calls &rsquo;await&rsquo; and will return the thunk&rsquo;s return value.  It
is intended to be called in a waitable procedure invoked by a-sync.
The timeout is single shot only - as soon as &rsquo;thunk&rsquo; has run once and
completed, the timeout will be removed from the event loop.  The
&rsquo;loop&rsquo; argument is optional: this procedure operates on the event loop
passed in as an argument, or if none is passed (or #f is passed), on
the default event loop.
</p>
<p>This procedure must (like the a-sync procedure) be called in the same
thread as that in which the event loop runs.
</p>
<p>Here is an example:
</p><div class="example">
<pre class="example">(set-default-event-loop!) ;; if none has yet been set
(a-sync (lambda (await resume)
	  (simple-format #t
			 &quot;Timeout ~A\n&quot;
			 (await-timeout! await resume
					 100
					 (lambda ()
					   &quot;expired&quot;)))))
(event-loop-run!)
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-a_002dsync_002dread_002dwatch_0021"></a>Scheme Procedure: <strong>a-sync-read-watch!</strong> <em>resume file proc [loop]</em></dt>
<dd><p>This is a convenience procedure for use with an event loop, which will
run &rsquo;proc&rsquo; in the event loop thread whenever &rsquo;file&rsquo; is ready for
reading, and apply &rsquo;resume&rsquo; (obtained from a call to a-sync) to the
return value of &rsquo;proc&rsquo;.  &rsquo;file&rsquo; can be a port or a file descriptor
(and if it is a file descriptor, the revealed count is not
incremented).  &rsquo;proc&rsquo; should take a single argument which will be set
by the event loop to &rsquo;in or &rsquo;excpt (see the documentation on
event-loop-add-read-watch! for further details).  It is intended to be
called in a waitable procedure invoked by a-sync.  The watch is
multi-shot - it is for the user to bring it to an end at the right
time by calling event-loop-remove-read-watch! in the waitable
procedure.  This procedure is mainly intended as something from which
higher-level asynchronous file operations can be constructed, such as
the await-readline! procedure.  The &rsquo;loop&rsquo; argument is optional: this
procedure operates on the event loop passed in as an argument, or if
none is passed (or #f is passed), on the default event loop
</p>
<p>Because this procedure takes a &rsquo;resume&rsquo; argument derived from the
a-sync procedure, it must (like the a-sync procedure) in practice be
called in the same thread as that in which the event loop runs.
</p>
<p>As an example of how to use a-sync-read-watch!, here is the
implementation of await-getline!:
</p><div class="example">
<pre class="example">(define await-getline!
   (case-lambda
    ((await resume port)
     (await-getline! await resume #f port))
    ((await resume loop port)
     (let ()
       (define text '())
       (a-sync-read-watch! resume
			   port
			   (lambda (status)
			     (if (eq? status 'excpt)
				 #f
				 (let next ()
				   (let ((ch (read-char port)))
				     (if (not (or (eof-object? ch)
						  (char=? ch #\newline)))
					 (begin
					   (set! text (cons ch text))
					   (if (char-ready? port)
					       (next)
					       'more))
					 (reverse-list-&gt;string text))))))
			   loop))
     (let next ((res (await)))
       (if (eq? res 'more)
	   (next (await))
	   (begin
	     (event-loop-remove-read-watch! port loop)
	     res))))))
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-await_002dgetline_0021"></a>Scheme Procedure: <strong>await-getline!</strong> <em>await resume [loop] port</em></dt>
<dd><p>This is a convenience procedure for use with an event loop, which will
start a read watch on &rsquo;port&rsquo; for a line of input.  It calls &rsquo;await&rsquo;
while waiting for input and will return the line of text received
(without the terminating &rsquo;\n&rsquo; character).  The event loop will not be
blocked by this procedure even if only individual characters are
available at any one time.  It is intended to be called in a waitable
procedure invoked by a-sync.  This procedure is implemented using
a-sync-read-watch!.  If an exceptional condition (&rsquo;excpt) is
encountered, #f will be returned.  The &rsquo;loop&rsquo; argument is optional:
this procedure operates on the event loop passed in as an argument, or
if none is passed (or #f is passed), on the default event loop.
</p>
<p>This procedure must (like the a-sync procedure) be called in the same
thread as that in which the event loop runs.
</p>
<p>Here is an example:
</p><div class="example">
<pre class="example">(set-default-event-loop!) ;; if none has yet been set
(a-sync (lambda (await resume)
	  (display &quot;Enter a line of text at the keyboard\n&quot;)
	  (simple-format #t
			 &quot;The line was: ~A\n&quot;
			 (await-getline! await resume
					 (open &quot;/dev/tty&quot; O_RDONLY)))))
(event-loop-run!)
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-a_002dsync_002dwrite_002dwatch_0021"></a>Scheme Procedure: <strong>a-sync-write-watch!</strong> <em>resume file proc [loop]</em></dt>
<dd><p>This is a convenience procedure for use with an event loop, which will
run &rsquo;proc&rsquo; in the event loop thread whenever &rsquo;file&rsquo; is ready for
writing, and apply &rsquo;resume&rsquo; (obtained from a call to a-sync) to the
return value of &rsquo;proc&rsquo;.  &rsquo;file&rsquo; can be a port or a file descriptor
(and if it is a file descriptor, the revealed count is not
incremented).  &rsquo;proc&rsquo; should take a single argument which will be set
by the event loop to &rsquo;out or &rsquo;excpt (see the documentation on
event-loop-add-write-watch! for further details).  It is intended to
be called in a waitable procedure invoked by a-sync.  The watch is
multi-shot - it is for the user to bring it to an end at the right
time by calling event-loop-remove-write-watch! in the waitable
procedure.  This procedure is mainly intended as something from which
higher-level asynchronous file operations can be constructed.  The
&rsquo;loop&rsquo; argument is optional: this procedure operates on the event loop
passed in as an argument, or if none is passed (or #f is passed), on
the default event loop
</p>
<p>Because this procedure takes a &rsquo;resume&rsquo; argument derived from the
a-sync procedure, it must (like the a-sync procedure) in practice be
called in the same thread as that in which the event loop runs.
</p></dd></dl>

<p>The (async event-loop) module also loads the <a href="monotonic-time.html#monotonic-time">(a-sync monotonic-time)</a> module.
</p><hr>
<div class="header">
<p>
Next: <a href="monotonic-time.html#monotonic-time" accesskey="n" rel="next">monotonic time</a>, Previous: <a href="coroutines.html#coroutines" accesskey="p" rel="prev">coroutines</a>, Up: <a href="index.html#Top" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>



</body>
</html>
