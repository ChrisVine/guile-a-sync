<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on February, 28 2016 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>guile-a-sync: coroutines</title>

<meta name="description" content="guile-a-sync: coroutines">
<meta name="keywords" content="guile-a-sync: coroutines">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="coroutines"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="a-sync.html#Top" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="a-sync_2.html#event-loop" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[ &lt;&lt; ]</td>
<td valign="middle" align="left">[<a href="a-sync.html#Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[ &gt;&gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="a-sync.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="a-sync_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<hr size="1">
<h3 class="node"> coroutines </h3>

<p>The (a-sync coroutines) module provides the following procedures:
</p>
<dl>
<dt><u>Scheme Procedure:</u> <b>make-iterator</b><i> proc . args</i>
<a name="IDX1"></a>
</dt>
<dd><p>This procedure takes a generator procedure, namely a procedure which
has a 'yield' parameter for its first or only argument, followed by
such other arguments (other than the one for the 'yield' parameter) as
the generator procedure requires, and constructs an iterator from
them.  When the iterator is invoked, it will begin executing the
procedure unless and until the argument comprising the yield procedure
is called, which will cause the iterator to suspend computation and
instead return the value passed to yield (yield is a procedure taking
no or one argument).  If invoked again, the iterator will resume
computation at the point where it last left off (returning the value,
if any, passed to the iterator on resuming).  When the generator
procedure has executed to the end, the iterator returns
'stop-iteration.  This procedure has some resemblance to call/ec,
except that (i) instead of executing the passed procedure immediately,
it returns an iterator which will do so, (ii) it is resumable, and
(iii) the procedure to be executed can receive starting arguments in
addition to the yield/break argument, to provide an alternative to
binding them with a lambda closure.  It is similar to ECMAScript
generators and python generators.
</p></dd></dl>

<dl>
<dt><u>Scheme Procedure:</u> <b>make-coroutine</b><i> proc . args</i>
<a name="IDX2"></a>
</dt>
<dd><p>This procedure takes a generator procedure, namely a procedure which
has a 'yield' parameter for its first or only argument, followed by
such other arguments (other than the one for the 'yield' parameter) as
the generator procedure requires, and constructs a coroutine.  It is
similar to make-iterator, in that it takes a generator procedure and
returns a lambda object (a coroutine) which when called will begin
executing the generator procedure unless and until the argument
comprising the yield procedure is called, which will cause computation
to be suspended.  However unlike make-iterator, the resumption
continuation generated on yielding is returned by the coroutine when
yielding rather than being stored internally in an iterator, so there
is no explicit retained mutable state.  The return value of the
coroutine comprises two values: first the resumption continuation, and
second the value (if any) passed to 'yield' when called.  If the
returned resumption continuation is subsequently called again,
computation will be resumed at the point where it last left off (the
yield procedure returning the value, if any, passed to the
continuation on resuming) until it completes or it again calls the
yield procedure.
</p>
<p>Upon the generator procedure finally completing, the value to which it
evaluates is returned by the resumption continuation together with a
continuation value of #f.  This differs from the behaviour of
make-iterator, which returns 'stop-iteration when the generator
procedure finishes to completion and ignores its return value.
</p></dd></dl>

<dl>
<dt><u>Scheme Procedure:</u> <b>a-sync</b><i> waitable . args</i>
<a name="IDX3"></a>
</dt>
<dd><p>a-sync takes a waitable procedure (namely a procedure which takes
'await' as its first parameter, which is a yield procedure obtained by
a call to make-iterator, and 'resume' as its second parameter, which
is an iterator constructed by make-iterator), followed by such other
arguments (if any) as the waitable procedure requires to be passed on
to it.  The 'resume' argument must only be called by an asynchronous
callback, and the 'await' argument must only be called by the waitable
procedure in order to block until the callback is ready to let it
resume.  When it unblocks, the 'await' argument returns the value (if
any) passed to 'resume' by the callback.  This async procedure must be
called in the same thread as that in which the event loop runs.
</p>
<p>None of the code in the waitable procedure should block on other
things in the program, except by calls to await (which do not in fact
block, even though they appear to do so).
</p>
<p>The way it works is that the call to a-sync will begin executing the
waitable procedure and will return as soon as the first (or only) call
to 'await' is made by that procedure, or as soon as the waitable
procedure returns if it makes no calls to 'await'.  Any subsequent
resumptions of the waitable procedure will take place in the event
loop concerned as delimited continuations, via the calls to 'resume'
made by the callbacks.  The effect of the waitable procedure
subsequently ending, or of further calls to 'await' being made within
the same waitable procedure, is to return control to the event loop by
recommencing execution at the point where the most recent previous
call to 'resume' was made by the last callback to execute.
</p>
<p>An exception thrown in the waitable procedure before the first call to
'await' which is not handled locally will propagate out of the a-sync
procedure normally.  Any exception thrown subsequently in the waitable
procedure which is not handled locally will propagate into the
previously called callback at the point where 'resume' was last
called.  If this is handled locally in the callback by putting a catch
block around resume, then control will be returned to the event loop
and the remainder of the waitable procedure will not execute.  If that
exception is not handled locally in the callback, or if the callback
throws an exception of its own, then it will propagate out of the
event loop.  If the event loop in the event-loop module is used, this
means that it will propagate out of the call to event-loop-run!.  If
an exception propagates out of event-loop-run! for that or some other
reason, then the event loop will be left in a valid state and it will
be as if event-loop-quit! had been called on it, but it is then up to
the user to catch that exception once it is out of event-loop-run! if
she does not want the program to terminate.
</p>
<p>After the call to 'resume', the callback should normally just return
(with a #t or #f value in the case of a file watch or a timeout on an
event-loop object from the event loop module).  If a-sync is used with
a file watch or timeout on an event-loop object constructed by
make-event-loop, the watch callback or timeout callback should
normally, when the call to 'resume' returns, either always return #f
(so the callback only fires once) or always return #t (so it is
responsibility of the waitable procedure to terminate the watch or
timeout repetitions).  That way, there can never be a case where the
callback has been removed from the event loop by returning false but
the waitable procedure still thinks it has a call to 'await' to be
made.  The <a href="a-sync_2.html#event-loop">event-loop</a> module has a-sync-run-task!,
a-sync-run-task-in-thread!, a-sync-run-timeout!,
a-sync-run-timeout-once!, a-sync-run-read-watch!,
a-sync-run-read-watch-once!, a-sync-run-write-watch! and
a-sync-run-write-watch-once! convenience procedures which will
correctly set this up for you automatically.  If those convenience
procedures are used, exceptions should always be handled locally in
the waitable procedure (and if the callback might throw, in the
callback also) if it is undesirable that uncaught exceptions propagate
out of event-loop-run!.  In the case of a-sync-run-task-in-thread!,
that procedure also takes an optional handler argument which will
handle any exceptions thrown by the task: otherwise the task thread
throwing would terminate the program if not caught within the task.
</p>
<p>There can be as many calls to 'await' and asynchronous callbacks in
any one waitable procedure as wanted, to enable composition of
asynchronous operations.  However, you cannot run two or more
asynchronous tasks at the same time with the same await-resume pair
without an intervening call to await except by doing extra work,
because the first call to 'await' will match the first callback which
happens to call 'resume', and so on.  In such cases, 'resume' would
need to return something like a key-value pair so that the result can
be correctly identified.  Accordingly this practice is discouraged.
Instead, when composing asynchronous tasks within any one waitable
procedure, operate on a 'start-task -&gt; await-on-result -&gt; start-task
-&gt; await-on-result ...' basis, and make calls to a-sync on separate
waitable procedures for tasks which are to run independently.  This is
easy using the convenience procedures mentioned above (see the
examples).  A waitable procedure can itself call a-sync to construct
another await-resume pair for the purpose of starting other
asynchronous events.
</p>
<p>This procedure can be used with any event loop, including the glib
event loop provided by guile-gnome and so with gtk+ callbacks, and
with the event loop in the event-loop module.
</p></dd></dl>


<hr size="1">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="a-sync.html#Top" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="a-sync_2.html#event-loop" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[ &lt;&lt; ]</td>
<td valign="middle" align="left">[<a href="a-sync.html#Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[ &gt;&gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="a-sync.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="a-sync_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated on <i>February, 28 2016</i> using <a href="http://texi2html.cvshome.org/"><i>texi2html 1.76</i></a>.
 </font>
 <br>

</p>
</body>
</html>
