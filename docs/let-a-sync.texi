@node let-a-sync,,gnome glib,Top

This (a-sync let-a-sync) module provides a let-a-sync* macro interface
for the a-sync procedure provided by the @ref{coroutines,,(a-sync
coroutines)} module.

@deffn {Syntax} (let-a-sync* [loop] ((var (await-proc)) ...) await-proc ...)
This module provides the let-a-sync* macro, which enables asynchronous
tasks to be composed on an event loop using let* type syntax.

The 'loop' argument of let-a-sync* is optional.  If an event loop
constructed by make-event-loop is passed to 'loop', then that is the
main loop on which the tasks will be composed, otherwise if there is
no 'loop' argument (or #f is passed to it) the default main loop will
be used.  This is followed by bindings which are optional (there need
not be any), each of which must be initialised by a
'let-a-sync*'-capable procedure, and following the bindings there must
be a body of 'let-a-sync*'-capable procedures executed solely for the
purpose of asynchronous side effects (this macro does not, and cannot,
return a value because as soon as the first await is made control is
passed to the event loop).  As in the case of let*, unlike the
bindings the body cannot be empty - there must be at least one
'let-a-sync*'-capable procedure in the body.

As in the case of let*, each 'let-a-sync*'-capable procedure
initializing a binding can see the values of the initializations made
prior to it.

A 'let-a-sync*'-capable procedure is one which takes an 'await' and
'yield' procedure from a-sync as its first and second arguments, and
an event loop (or #f) as it third argument, followed by such further
arguments as it requires.  All the the await-task!,
await-task-in-thread!, await-timeout! and await-getline! procedures
provided by the (a-sync event-loop) module are 'let-a-sync*'-capable.
In addition, to make an ordinary body of code which does not block
(and which does not need to invoke a-sync's await procedure) usable by
let-a-sync*, the no-await macro can be used to generate a
'let-a-sync*'-capable procedure for it (see below).

Each binding is initialized as if sequentially (although it is done
asynchronously on the relevant event loop).  An initialization does
not begin until an earlier one has completed.  In addition, each
clause in the body is executed sequentially in turn, but does so
asynchronously on the event loop using 'await' semantics.

When calling a 'let-a-sync*'-capable procedure within a 'let-a-sync*'
block (including when initializing its bindings), the 'await' and
'yield' and event-loop arguments are not explicitly passed to it.  The
let-a-sync* macro will do it for you.

@example
(set-default-event-loop!) ;; if none has yet been set
(let-a-sync* ((line (await-getline! (open "/dev/tty" O_RDONLY))))
	  ((no-await (simple-format #t
				    "The line was: ~A\n"
				     line))))
(event-loop-run!)
@end example

Each block of code within a let-a-sync* block will run independently
of (and concurrently with) code in other let-a-sync* blocks.
Asynchronous operations are only serialized within any one let-a-sync*
block.  As soon as any code calls a-sync's 'await' procedure in any
let-a-sync* block, let-a-sync* will return and begin executing
whatever follows it.

Other examples of the use of this macro are given in the documentation
of the @ref{coroutines,,(a-sync coroutines)} module.
@end deffn

@deffn {Syntax} (no-await body0 body1 ...)
This macro will generate a 'let-a-sync*'-capable procedure from a body
of code which does not block.  It can be passed to let-a-sync*, either
as an initializer or as a clause in its body.

@example
((no-await (display "This is non-blocking code\n")))
@end example
@end deffn
