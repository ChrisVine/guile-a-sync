This is guile-a-sync.info, produced by makeinfo version 6.3 from
guile-a-sync.texi.


File: guile-a-sync.info,  Node: Top,  Next: overview

guile-a-sync reference
**********************

This is the guile-a-sync library.  It provides both an asynchronous
event loop for guile-2.0, and coroutines to enable an event loop
(including other event loops such as the glib event loop) to be used
with 'await' semantics to deal with inversion of control - otherwise
known as "callback hell".

* Menu:

General overview
* overview::       General overview of the operation of the library

Modules
* coroutines::     (a-sync coroutines) module - provides coroutines for await semantics on asynchronous events
* event loop::     (a-sync event-loop) module - provides an event loop for asynchronous events
* monotonic time:: (a-sync monotonic-time) module - enables monotonic time to be used for timeouts
* gnome glib::     (a-sync gnome-glib) module - provides some convenience await procedures for the glib main loop
* compose::        (a-sync compose) module - provides the compose-a-sync macro interface for the a-sync coroutine


File: guile-a-sync.info,  Node: overview,  Next: coroutines,  Prev: Top

*An overview of asynchronous programming with coroutines*

   Asynchronous programming using coroutines might mitigate "callback
hell", but it can still be troublesome to think about.  It can help to
compare it to threads.

   Each 'a-sync' block (see *note (a-sync coroutines): coroutines.) or
'compose-a-sync' block (see *note (a-sync compose): compose.) is a
separate unit of computation, which appears within itself to proceed
sequentially even though in fact it executes asynchronously on an event
loop.  Each such block also appears to execute concurrently with other
'a-sync' or 'compose-a-sync' blocks running on the same event loop.
Each 'a-sync' or 'compose-a-sync' block is therefore in some sense
analogous to a thread of execution.

   If the event loop provided by the *note (a-sync event-loop): event
loop. module is in use, the mechanism by which these "pseudo-threads"
execute on the event loop is by a call to event-loop-run!.
event-loop-run!  therefore behaves in a way which is in some sense
analogous to a scheduler, although multi-plexing is co-operative and/or
i/o event based rather than pre-emptive.

   event-loop-run!  also performs the equivalent of a join operation on
these "pseudo-threads" running on the event loop in question, because by
default it returns when there are no further events to be dealt with
(that is, when all "pseudo-threads" have completed).  So given the
following code, the sum of 1 and 1 will only be printed when both the
timeout has expired and the calculation has been made, both of which
will run as if concurrently (the summing will complete before the
timeout expires):

     (let ((loop (make-event-loop))
           (ret #f))
       (a-sync (lambda (await resume)
     	    (await-timeout! await resume loop
     			    100
     			    (lambda () #f))))
       (a-sync (lambda (await resume)
     	    (set! ret
     		  (await-task! await resume loop
     			       (lambda ()
     				 (+ 1 1))))))
       (event-loop-run! loop)
       (display ret)(newline))

   Apart from joining on event-loop-run!, there is no built in
abstraction for two "pseudo-threads" (that is two 'a-sync' or
'compose-a-sync' blocks) running on the same event loop to
intercommunicate.  This can be done using shared data (helped by the
fact that all the mutation would be carried out in the same native OS
thread, the event-loop thread), but at present it is messy.  Instead of
starting two intercommunicating "pseudo-threads", the preferred method
of achieving a similar result is to use generators (see the
await-generator!  procedure in the *note (a-sync event-loop): event
loop. module).

   Apart from these "pseudo-threads", true parallelism is possible using
native OS threads, with the await-task-in-thread!,
await-task-in-event-loop!, await-generator-in-thread!  and
await-generator-in-event-loop!  procedures.


File: guile-a-sync.info,  Node: coroutines,  Next: event loop,  Prev: overview,  Up: Top

The (a-sync coroutines) module provides the following procedures:

 -- Scheme Procedure: make-iterator proc . args
     This procedure takes a generator procedure, namely a procedure
     which has a 'yield' parameter for its first or only argument,
     followed by such other arguments (other than the one for the
     'yield' parameter) as the generator procedure requires, and
     constructs an iterator from them.  When the iterator (which
     optionally takes no or one argument) is invoked, it will begin
     executing the procedure unless and until the argument comprising
     the yield procedure is called, which will cause the iterator to
     suspend computation and instead return the value passed to yield,
     if any (yield is a procedure taking no or one argument).  If
     invoked again, the iterator will resume computation at the point
     where it last left off (returning the value, if any, passed to the
     iterator on resuming).  When the generator procedure has executed
     to the end, the iterator returns 'stop-iteration.  This procedure
     has some resemblance to call/ec, except that (i) instead of
     executing the passed procedure immediately, it returns an iterator
     which will do so, (ii) it is resumable, and (iii) the procedure to
     be executed can receive starting arguments in addition to the
     yield/break argument, to provide an alternative to binding them
     with a lambda closure.  It is similar to ECMAScript generators and
     python generators.

 -- Scheme Procedure: make-coroutine proc . args
     This procedure takes a generator procedure, namely a procedure
     which has a 'yield' parameter for its first or only argument,
     followed by such other arguments (other than the one for the
     'yield' parameter) as the generator procedure requires, and
     constructs a coroutine.  It is similar to make-iterator, in that it
     takes a generator procedure and returns a lambda object (a
     coroutine) which when called will begin executing the generator
     procedure unless and until the argument comprising the yield
     procedure is called, which will cause computation to be suspended.
     However unlike make-iterator, the resumption continuation generated
     on yielding is returned by the coroutine when yielding rather than
     being stored internally in an iterator, so there is no explicit
     retained mutable state.  The return value of the coroutine
     comprises two values: first the resumption continuation, and second
     the value (if any) passed to 'yield' when called.  If the returned
     resumption continuation is subsequently called again, computation
     will be resumed at the point where it last left off (the yield
     procedure returning the value, if any, passed to the continuation
     on resuming) until it completes or it again calls the yield
     procedure.

     Upon the generator procedure finally completing, the value to which
     it evaluates is returned by the resumption continuation together
     with a continuation value of #f.  This differs from the behaviour
     of make-iterator, which returns 'stop-iteration when the generator
     procedure finishes to completion and ignores its return value.

 -- Scheme Procedure: a-sync waitable . args
     a-sync takes a waitable procedure (namely a procedure which takes
     'await' as its first parameter, which is a yield procedure obtained
     by a call to make-iterator, and 'resume' as its second parameter,
     which is an iterator constructed by make-iterator), followed by
     such other arguments (if any) as the waitable procedure requires to
     be passed on to it.  The 'resume' argument must only be called by
     an asynchronous callback, and the 'await' argument must only be
     called by the waitable procedure in order to block until the
     callback is ready to let it resume.  When it unblocks, the 'await'
     argument returns the value (if any) passed to 'resume' by the
     callback.  This async procedure must be called in the same thread
     as that in which the event loop runs (as must 'await' and
     'resume').

     None of the code in the waitable procedure should block on other
     things in the program, except by calls to await (which do not in
     fact block, even though they appear to do so).

     The way it works is that the call to a-sync will begin executing
     the waitable procedure and will return as soon as the first (or
     only) call to 'await' is made by that procedure, or as soon as the
     waitable procedure returns if it makes no calls to 'await'.  Any
     subsequent resumptions of the waitable procedure will take place in
     the event loop concerned as delimited continuations, via the calls
     to 'resume' made by the callbacks.  The effect of the waitable
     procedure subsequently ending, or of further calls to 'await' being
     made within the same waitable procedure, is to return control to
     the event loop by recommencing execution at the point where the
     most recent previous call to 'resume' was made by the last callback
     to execute.

     An exception thrown in a waitable procedure before the first call
     to 'await' to be made by it which is not handled locally will
     propagate out of the a-sync procedure where it may be caught
     normally.  However, if so caught but a callback established by the
     same waitable procedure call still runs and invokes 'resume', the
     waitable procedure will begin running again in the callback.  If
     the same exception is thrown again in consequence, it will
     propagate out of 'resume' in that callback, and then out of the
     event loop - if the event loop in the event-loop module is used,
     this means that it will propagate out of the call to
     event-loop-run!.  It is therefore best if such exceptions are
     handled locally within the waitable procedure.  Any exception
     thrown in the waitable procedure after the first call to 'await'
     which is not handled locally will propagate into the previously
     called callback at the point where 'resume' was last called.  If
     this is handled in the callback, then control will be returned to
     the event loop and the remainder of the waitable procedure will not
     execute.  If that exception is not handled locally in the callback,
     or if the callback throws an exception of its own, then it will
     propagate out of the event loop - if the event loop in the
     event-loop module is used, this means that it will propagate out of
     the call to event-loop-run!.  If an exception propagates out of
     event-loop-run!  for that or some other reason, then the event loop
     will be left in a valid state and it will be as if event-loop-quit!
     had been called on it, but it is then up to the user to catch that
     exception once it is out of event-loop-run!  if she does not want
     the program to terminate.

     After the call to 'resume', the callback should normally just
     return (with a #t or #f value in the case of a file watch or a
     timeout on an event-loop object from the event loop module).  If
     a-sync is used with a file watch or timeout on an event-loop object
     constructed by make-event-loop, the watch callback or timeout
     callback should normally, when the call to 'resume' returns, either
     always return #f (so the callback only fires once) or always return
     #t (so it is responsibility of the waitable procedure to terminate
     the watch or timeout repetitions).  That way, there can never be a
     case where the callback has been removed from the event loop by
     returning false but the waitable procedure still thinks it has a
     call to 'await' to be made.  The *note event-loop: event loop.
     module has await-task!, await-task-in-thread!,
     await-task-in-event-loop!, await-generator!,
     await-generator-in-thread!, await-generator-in-event-loop!,
     await-timeout!, a-sync-read-watch!, await-getline!,
     await-geteveryline!, await-getsomelines!, a-sync-write-watch!  and
     await-put-string!  convenience procedures which will correctly set
     this up for you automatically, and the *note compose: compose.
     module provides a compose-a-sync macro for composition.  If those
     convenience procedures are used, exceptions should always be
     handled locally in the waitable procedure (and if the callback
     might throw, in the callback also) if it is undesirable that
     uncaught exceptions propagate out of event-loop-run!.  In the case
     of await-task-in-thread!, that procedure also takes an optional
     handler argument which will handle any exceptions thrown by the
     task: otherwise the task thread throwing would terminate the
     program if not caught within the task.

     There can be as many calls to 'await' and asynchronous callbacks in
     any one waitable procedure as wanted, to enable composition of
     asynchronous operations.  However, you cannot run two or more
     asynchronous tasks at the same time with the same await-resume pair
     without an intervening call to await except by doing extra work,
     because the first call to 'await' will match the first callback
     which happens to call 'resume', and so on.  In such cases, 'resume'
     would need to return something like a key-value pair so that the
     result can be correctly identified.  Accordingly this practice is
     discouraged.  Instead, when composing asynchronous tasks within any
     one waitable procedure, operate on a 'start-task -> await-on-result
     -> start-task -> await-on-result ...'  basis, and make calls to
     a-sync on separate waitable procedures for tasks which are to run
     independently (as soon as any code calls a-sync's 'await' procedure
     in any a-sync block, a-sync will return and whatever follows it
     will begin executing, including any following a-sync block).  The
     convenience procedures mentioned above make this easy for many use
     cases (see the examples below).  A waitable procedure can itself
     call a-sync to construct another await-resume pair for the purpose
     of starting other asynchronous events.

     So, don't do this:

          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)

          	  (timeout-post! 100
          			 (lambda ()
          			   (resume "expired")
          			   #f))
          	  (event-post! (lambda ()
          			 (resume (+ 1 1))))

          	  (simple-format #t "Timeout ~A\n" (await))
          	  (simple-format #t "1 + 1 is ~A\n" (await))))
          (event-loop-run!)

     Instead do this, where the two asynchronous operations are to run
     consecutively:

          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)

          	  (timeout-post! 100
          			 (lambda ()
          			   (resume "expired")
          			   #f))
          	  (simple-format #t "Timeout ~A\n" (await))
          	  (event-post! (lambda ()
          			 (resume (+ 1 1))))

          	  (simple-format #t "1 + 1 is ~A\n" (await))))
          (event-loop-run!)

     or this, where the two asynchronous operations are to run
     concurrently (the summing of 1 and 1 will finish before the
     timeout):

          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (timeout-post! 100
          			 (lambda ()
          			   (resume "expired")
          			   #f))
          	  (simple-format #t "Timeout ~A\n" (await))))
          (a-sync (lambda (await resume)
          	  (event-post! (lambda ()
          			 (resume (+ 1 1))))
          	  (simple-format #t "1 + 1 is ~A\n" (await))))

          (event-loop-run!)

     or this, to loop asynchronously with a series of results:

          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  ;; executing task in event loop thread
          	  (let loop ((count 0))
          	    (if (< count 5)
          		(begin
          		  (event-post! (lambda () (resume (* 2 count))))
          		  (loop (1+ count)))
          		(event-post! (lambda () (resume 'stop-iteration)))))
          	  (let loop ()
          	    (let ((res (await)))
          	      (when (not (eq? 'stop-iteration res))
          		(display res)(newline)
          		(loop))))

          	  ;; executing task in a worker thread
          	  (call-with-new-thread
          	   (lambda ()
          	     (let loop ((count 5))
          	       (if (< count 10)
          		   (begin
          		     (event-post! (lambda () (resume (* 2 count))))
          		     (loop (1+ count)))
          		   (event-post! (lambda () (resume 'stop-iteration)))))))
          	  (let loop ()
          	    (let ((res (await)))
          	      (when (not (eq? 'stop-iteration res))
          		(display res)(newline)
          		(loop))))
          	  (event-loop-block! #f)))
          (event-loop-block! #t) ;; worker thread in operation
          (event-loop-run!)

     Or better, for many use cases when composing on the event loop from
     the *note event-loop: event loop. module, you can use the await
     helper procedures, as follows (in this example the two asynchronous
     operations run consecutively):

          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (simple-format #t
          			 "Timeout ~A\n"
          			 (await-timeout! await resume
          					 100
          					 (lambda ()
          					   "expired")))
          	  (simple-format #t "1 + 1 is ~A\n"
          			 (await-task! await resume
          				      (lambda ()
          					(+ 1 1))))))
          (event-loop-run!)

     or this, where the two asynchronous operations run concurrently
     (the summing of 1 and 1 will finish before the timeout)

          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (simple-format #t
          			 "Timeout ~A\n"
          			 (await-timeout! await resume
          					 100
          					 (lambda ()
          					   "expired")))))
          (a-sync (lambda (await resume)
          	  (simple-format #t "1 + 1 is ~A\n"
          			 (await-task! await resume
          				      (lambda ()
          					(+ 1 1))))))
          (event-loop-run!)

     or this, to loop asynchronously with a series of results:

          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (await-generator! await resume
          			    (lambda (yield)
          			      (let loop ((count 0))
          				(when (< count 5)
          				  (yield (* 2 count))
          				  (loop (1+ count)))))
          			    (lambda (val)
          			      (display val)
          			      (newline)))
                    (await-generator-in-thread! await resume
          				      (lambda (yield)
          					(let loop ((count 5))
          					  (when (< count 10)
          					    (yield (* 2 count))
          					    (loop (1+ count)))))
          				      (lambda (val)
          					(display val)
          					(newline)))
          	  (event-loop-block! #f)))
          (event-loop-block! #t) ;; worker thread in operation
          (event-loop-run!)

     Or the compose-a-sync macro in the *note compose: compose. module
     can be used so that these examples are constructed as follows (in
     this first case the two asynchronous operations run consecutively)

          (set-default-event-loop!) ;; if none has yet been set
          (compose-a-sync ((ret1 (await-timeout! 100
          				       (lambda ()
          					 "expired")))
          		 (ignore ((no-await (simple-format #t "Timeout ~A\n" ret1))))
          		 (ret2 (await-task! (lambda ()
          				      (+ 1 1)))))
          	   ((no-await (simple-format #t "1 + 1 is ~A\n" ret2))))
          (event-loop-run!)

     and this, where the two asynchronous operations run concurrently
     (the summing of 1 and 1 will finish before the timeout)

          (set-default-event-loop!) ;; if none has yet been set
          (compose-a-sync ((ret (await-timeout! 100
          				      (lambda ()
          				        "expired"))))
          	   ((no-await (simple-format #t "Timeout ~A\n" ret))))
          (compose-a-sync ((ret (await-task! (lambda ()
          				     (+ 1 1)))))
          	   ((no-await (simple-format #t "1 + 1 is ~A\n" ret))))
          (event-loop-run!)

     or this, to loop asynchronously with a series of results:

          (set-default-event-loop!) ;; if none has yet been set
          (compose-a-sync ()
          		(await-generator! (lambda (yield)
          				    (let loop ((count 0))
          				      (when (< count 5)
          					(yield (* 2 count))
          					(loop (1+ count)))))
          				  (lambda (val)
          				    (display val)
          				    (newline)))
          		(await-generator-in-thread! (lambda (yield)
          					      (let loop ((count 5))
          						(when (< count 10)
          						  (yield (* 2 count))
          						  (loop (1+ count)))))
          					    (lambda (val)
          					      (display val)
          					      (newline)))
          		((no-await (event-loop-block! #f))))
          (event-loop-block! #t) ;; worker thread in operation
          (event-loop-run!)

     The a-sync procedure can be used with any event loop, including the
     glib event loop provided by guile-gnome and so with gtk+ callbacks,
     and with the event loop in the event-loop module.

     For a further overview of the operation of 'a-sync', see the *note
     general overview: overview.


File: guile-a-sync.info,  Node: event loop,  Next: monotonic time,  Prev: coroutines,  Up: Top

The (a-sync event-loop) module provides an event loop for asynchronous
operations.  The event loop does not of itself start any new threads.
Instead it runs in the thread which calls event-loop-run!: that
procedure will block while there are events to be processed.  In most
programs the event loop will run in the main program thread, with which
the program began.  Many programs using event loops are entirely single
threaded.

   However, the event loop provided by this module does support multiple
threads.  Most of the event loop procedures in this module are thread
safe and may be called in any thread.  The thread safe procedures are
event-loop-run!  (as mentioned, this will cause the event loop to run in
the thread which calls it), event-loop-block!, event-loop-quit!,
event-post!, event-loop-tasks, event-loop-add-read-watch!,
event-loop-add-write-watch!, event-loop-remove-read-watch!,
event-loop-remove-write-watch!, timeout-post!  and timeout-remove!.  In
particular, event-post!  allows worker threads to post an event to an
event loop, say with the result of a computation, so that the event
callback will execute in the event loop thread.

   The file watches provided by this module use guile's wrapper for the
select() system call.  This has two consequences.  First, in linux
select() applied to sockets can give rise to spurious wake-ups, which
means that it may be best with sockets to set the socket as non-blocking
using the guile wrapper for the fcntl() system call in order to prevent
a blocking read where it is not expected (EAGAIN/EWOULDBLOCK is handled
correctly by the await-getline!, await-geteveryline!  and
await-getsomelines!  procedures from version 0.5, and by
await-put-string!).  Secondly, with select() the file descriptor value
of a port passed to the watch should not exceed FD_SETSIZE. Normally, by
default the maximum soft user limit for open files is the same as
FD_SETSIZE, and it is best if this situation is retained by user code.

   Where a file watch on a file descriptor or port has been added with
event-loop-add-read-watch!  or event-loop-add-write-watch!, the event
loop should be treated as owning the status of the descriptor or port
until it has subsequently been removed with
event-loop-remove-read-watch!  or event-loop-remove-write-watch!.  In
particular, if the watch is on a port, an error in the fileno procedure
will arise at some point if the port is closed (say by calling close,
close-port, close-input-port or close-output-port) before its watch has
been removed from the event loop; if the watch is on a file descriptor
and the descriptor value is reused by the operating system, there may be
a phantom watch on the new descriptor.  Also note that if a worker
thread other than the event loop thread removes the watch and
immediately follows it with a close of the port or descriptor, the file
watch callback may be called once in consequence, so in such a case
either the callback should be ready to handle a possibly closed port or
descriptor or the worker thread should post the closing as an event
using event-post!.

   This modules provides the following procedures:

 -- Scheme Procedure: set-default-event-loop! [loop]
     The 'loop' (event loop) argument is optional.  This procedure sets
     the default event loop for the procedures in this module to the one
     passed in (which must have been constructed by the make-event-loop
     procedure), or if no argument is passed (or #f is passed), a new
     event loop will be constructed for you as the default, which can be
     accessed via the get-default-event-loop procedure.  The default
     loop variable is not a fluid or a parameter - it is intended that
     the default event loop is the same for every thread in the program,
     and that the default event loop would normally run in the thread
     with which the program started.  This procedure is not thread safe
     - if it might be called by a different thread from others which
     might access the default event loop, then external synchronization
     may be required.  However, that should not normally be an issue.
     The normal course would be to call this procedure once only on
     program start up, before other threads have started.  It is usually
     a mistake to call this procedure twice: if there are asynchronous
     events pending (that is, if event-loop-run!  has not returned) you
     will probably not get the results you expect.

     Note that if a default event-loop is constructed for you because no
     argument is passed (or #f is passed), no throttling arguments are
     applied to it (see the documentation on make-event-loop for more
     about that).  If throttling is wanted, the make-event-loop
     procedure should be called explicitly and the result passed to this
     procedure.

 -- Scheme Procedure: get-default-event-loop
     This returns the default loop set by the set-default-event-loop!
     procedure, or #f if none has been set.

 -- Scheme Procedure: make-event-loop [throttle-threshold
          throttle-delay]
     This constructs a new event loop object.  From version 0.8, this
     procedure optionally takes two throttling arguments for
     backpressure when applying the event-post!  procedure to the event
     loop.  The 'throttle-threshold' argument specifies the number of
     unexecuted tasks queued for execution, by virtue of calls to
     event-post!, at which throttling will first be applied.  Where the
     threshold is exceeded, throttling proceeds by adding a wait to any
     thread which calls the event-post!  procedure, equal to the cube of
     the number of times (if any) by which the number of queued tasks
     exceeds the threshold multiplied by the value of 'threshold-delay'.
     The value of 'threshold-delay' should be given in microseconds.
     Throttling is only applied where the call to event-post!  is made
     in a thread other than the one in which the event loop runs.

     So if the threshold given is 10000 tasks and the delay given is
     1000 microseconds, upon 10000 unexecuted tasks accumulating a delay
     of 1000 microseconds will be applied to callers of event-post!
     which are not in the event loop thread, at 20000 unexecuted tasks a
     delay of 8000 microseconds will be applied, and at 30000 unexecuted
     tasks a delay of 27000 microseconds will be applied, and so on.

     If throttle-threshold and throttle-delay arguments are not provided
     (or #f is passed for them), then no throttling takes place.

 -- Scheme Procedure: event-loop? obj
     This procedure indicates whether 'obj' is an event-loop object
     constructed by make-event-loop.

 -- Scheme Procedure: event-loop-run! [loop]
     The 'loop' (event loop) argument is optional.  This procedure
     starts the event loop passed in as an argument, or if none is
     passed (or #f is passed) it starts the default event loop.  The
     event loop will run in the thread which calls this procedure.  If
     this procedure has returned, including after a call to
     event-loop-quit!, this procedure may be called again to restart the
     event loop.  If a callback throws, or something else throws in the
     implementation, then this procedure will clean up the event loop as
     if event-loop-quit!  had been called, and the exception will be
     rethrown out of this procedure.

 -- Scheme Procedure: event-loop-add-read-watch! file proc [loop]
     The 'loop' (event loop) argument is optional.  This procedure will
     start a read watch in the event loop passed in as an argument, or
     if none is passed (or #f is passed), in the default event loop.
     The 'proc' callback should take a single argument, and when called
     this will be set to 'in or 'excpt.  The same port or file
     descriptor can also be passed to event-loop-add-write-watch, and if
     so and the descriptor is also available for writing, the write
     callback will also be called with its argument set to 'out.  If
     there is already a read watch for the file passed, the old one will
     be replaced by the new one.  If 'proc' returns #f, the read watch
     will be removed from the event loop, otherwise the watch will
     continue.  This is thread safe - any thread may add a watch, and
     the callback will execute in the event loop thread.  The file
     argument can be either a port or a file descriptor.  If 'file' is a
     file descriptor, any port for the descriptor is not referenced for
     garbage collection purposes - it must remain valid while operations
     are carried out on the descriptor.  If 'file' is a buffered port,
     buffering will be taken into account in indicating whether a read
     can be made without blocking (but on a buffered port, for
     efficiency purposes each read operation in response to this watch
     should usually exhaust the buffer by calling drain-input or by
     looping on char-ready?).

     This procedure should not throw an exception unless memory is
     exhausted.

 -- Scheme Procedure: event-loop-add-write-watch! file proc [loop]
     The 'loop' (event loop) argument is optional.  This procedure will
     start a write watch in the event loop passed in as an argument, or
     if none is passed (or #f is passed), in the default event loop.
     The 'proc' callback should take a single argument, and when called
     this will be set to 'out or 'excpt.  The same port or file
     descriptor can also be passed to event-loop-add-read-watch, and if
     so and the descriptor is also available for reading or in
     exceptional condition, the read callback will also be called with
     its argument set to 'in or 'excpt (if both a read and a write watch
     have been set for the same file argument, and there is an
     exceptional condition, it is the read watch procedure which will be
     called with 'excpt rather than the write watch procedure, so if
     that procedure returns #f only the read watch will be removed).  If
     there is already a write watch for the file passed, the old one
     will be replaced by the new one.  If 'proc' returns #f, the write
     watch will be removed from the event loop, otherwise the watch will
     continue.  This is thread safe - any thread may add a watch, and
     the callback will execute in the event loop thread.  The file
     argument can be either a port or a file descriptor.  If 'file' is a
     file descriptor, any port for the descriptor is not referenced for
     garbage collection purposes - it must remain valid while operations
     are carried out on the descriptor.

     If 'file' is a buffered port, buffering will be taken into account
     in indicating whether a write can be made without blocking, either
     because there is room in the buffer for a character, or because the
     underlying file descriptor is ready for a character.  This can have
     unintended consequences: if the buffer is full but the underlying
     file descriptor is ready for a character, the next write will cause
     a buffer flush, and if the size of the buffer is greater than the
     number of characters that the file can receive without blocking,
     blocking might still occur.  Unless the port will carry out a
     partial flush in such a case, this procedure will therefore
     generally work best with unbuffered ports (say by using the
     open-file, fdopen or duplicate-port procedure with the '0' mode
     option or the R6RS open-file-input-port procedure with a
     buffer-mode of none, or by calling setvbuf).

     This procedure should not throw an exception unless memory is
     exhausted.

 -- Scheme Procedure: event-loop-remove-read-watch! file [loop]
     The 'loop' (event loop) argument is optional.  This procedure will
     remove a read watch from the event loop passed in as an argument,
     or if none is passed (or #f is passed), from the default event
     loop.  The file argument may be a port or a file descriptor.  This
     is thread safe - any thread may remove a watch.  A file descriptor
     and a port with the same underlying file descriptor compare equal
     for the purposes of removal.

 -- Scheme Procedure: event-loop-remove-write-watch! file [loop]
     The 'loop' (event loop) argument is optional.  This procedure will
     remove a write watch from the event loop passed in as an argument,
     or if none is passed (or #f is passed), from the default event
     loop.  The file argument may be a port or a file descriptor.  This
     is thread safe - any thread may remove a watch.  A file descriptor
     and a port with the same underlying file descriptor compare equal
     for the purposes of removal.

 -- Scheme Procedure: event-post! action [loop]
     The 'loop' (event loop) argument is optional.  This procedure will
     post a callback for execution in the event loop passed in as an
     argument, or if none is passed (or #f is passed), in the default
     event loop.  The 'action' callback is a thunk.  This is thread safe
     - any thread may post an event (that is its main purpose), and the
     action callback will execute in the event loop thread.  Actions
     execute in the order in which they were posted.  If an event is
     posted from a worker thread, it will normally be necessary to call
     event-loop-block!  beforehand.

     This procedure should not throw an exception unless memory is
     exhausted.  If the 'action' callback throws, and the exception is
     not caught locally, it will propagate out of event-loop-run!.

     Where this procedure is called by other than the event loop thread,
     throttling may take place if the number of posted callbacks waiting
     to execute exceeds the threshold set for the event loop - see the
     documentation on make-event-loop for further details.

 -- Scheme Procedure: timeout-post! msecs action [loop]
     The 'loop' (event loop) argument is optional.  This procedure adds
     a timeout to the event loop passed in as an argument, or if none is
     passed (or #f is passed), to the default event loop.  The timeout
     will repeat unless and until the passed-in callback returns #f or
     timeout-remove!  is called.  The passed-in callback must be a
     thunk.  This procedure returns a tag symbol to which
     timeout-remove!  can be applied.  It may be called by any thread,
     and the timeout callback will execute in the event loop thread.

     This procedure should not throw an exception unless memory is
     exhausted.  If the 'action' callback throws, and the exception is
     not caught locally, it will propagate out of event-loop-run!.

 -- Scheme Procedure: timeout-remove! tag [loop]
     The 'loop' (event loop) argument is optional.  This procedure stops
     the timeout with the given tag from executing in the event loop
     passed in as an argument, or if none is passed (or #f is passed),
     in the default event loop.  It may be called by any thread.

 -- Scheme Procedure: event-loop-tasks [loop]
     This procedure returns the number of callbacks posted to an event
     loop with the event-post!  procedure which at the time still remain
     queued for execution.  Amongst other things, it can be used by a
     calling thread which is not the event loop thread to determine
     whether throttling is likely to be applied to it when calling
     event-post!  - see the documentation on make-event-loop for further
     details.

     The 'loop' (event loop) argument is optional: this procedure
     operates on the event loop passed in as an argument, or if none is
     passed (or #f is passed), on the default event loop.  This
     procedure is thread safe - any thread may call it.

     This procedure is first available in version 0.8 of this library.

 -- Scheme Procedure: event-loop-block! val [loop]
     By default, upon there being no more watches, timeouts and posted
     events for an event loop, event-loop-run!  will return, which is
     normally what you want with a single threaded program.  However,
     this is undesirable where a worker thread is intended to post an
     event to the main loop after it has reached a result, say via
     await-task-in-thread!, because the main loop may have ended before
     it posts.  Passing #t to the val argument of this procedure will
     prevent that from happening, so that the event loop can only be
     ended by calling event-loop-quit!, or by calling event-loop-block!
     again with a #f argument (to switch the event loop back to
     non-blocking mode, pass #f).  This is thread safe - any thread may
     call this procedure.  The 'loop' (event loop) argument is optional:
     this procedure operates on the event loop passed in as an argument,
     or if none is passed (or #f is passed), on the default event loop.

 -- Scheme Procedure: event-loop-quit! [loop]
     This procedure causes an event loop to unblock.  Any events
     remaining in the event loop will be discarded.  New events may
     subsequently be added after event-loop-run!  has unblocked and
     event-loop-run!  then called for them.  This is thread safe - any
     thread may call this procedure.  The 'loop' (event loop) argument
     is optional: this procedure operates on the event loop passed in as
     an argument, or if none is passed (or #f is passed), on the default
     event loop.

 -- Scheme Procedure: await-task-in-thread! await resume [loop] thunk
          [handler]
     The loop and handler arguments are optional.  The procedure will
     run 'thunk' in its own thread, and then post an event to the event
     loop specified by the 'loop' argument when 'thunk' has finished, or
     to the default event loop if no 'loop' argument is provided or if
     #f is provided as the 'loop' argument (pattern matching is used to
     detect the type of the third argument).  This procedure calls
     'await' and will return the thunk's return value.  It is intended
     to be called in a waitable procedure invoked by a-sync.  It will
     normally be necessary to call event-loop-block!  before invoking
     this procedure.  If the optional 'handler' argument is provided,
     then that handler will be run in the event loop thread if 'thunk'
     throws and the return value of the handler would become the return
     value of this procedure; otherwise the program will terminate if an
     unhandled exception propagates out of 'thunk'.  'handler' should
     take the same arguments as a guile catch handler (this is
     implemented using catch).

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs, where the result
     of calling 'thunk' will be received.  As mentioned above, the thunk
     itself will run in its own thread.

     As the worker thread calls event-post!, it might be subject to
     throttling by the event loop concerned.  See the documentation on
     the make-event-loop procedure for further information about that.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the worker thread starts), which
     shouldn't happen unless memory is exhausted or pthread has run out
     of resources.  Exceptions arising during execution of the task, if
     not caught by a handler procedure, will terminate the program.
     Exceptions thrown by the handler procedure will propagate out of
     event-loop-run!.

     Here is an example of the use of await-task-in-thread!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (simple-format #t "1 + 1 is ~A\n"
          			 (await-task-in-thread! await resume
          						(lambda ()
          						  (+ 1 1))))
          	  (event-loop-quit!)))
          (event-loop-block! #t) ;; because the task runs in another thread
          (event-loop-run!)

 -- Scheme Procedure: await-task-in-event-loop! await resume [waiter]
          worker thunk
     The 'waiter' argument is optional.  The 'worker' argument is an
     event loop running in a different thread than the one in which this
     procedure is called, and is the one in which 'thunk' will be
     executed by posting an event to that loop.  The result of executing
     'thunk' will then be posted to the event loop specified by the
     'waiter' argument, or to the default event loop if no 'waiter'
     argument is provided or if #f is provided as the 'waiter' argument,
     and will comprise this procedure's return value.  This procedure is
     intended to be called in a waitable procedure invoked by a-sync.
     It will normally be necessary to call event-loop-block!  on
     'waiter' (or on the default event loop) before invoking this
     procedure.

     This procedure calls 'await' and must (like the a-sync procedure)
     be called in the same thread as that in which the 'waiter' or
     default event loop runs (as the case may be).

     This procedure acts as a form of channel through which two
     different event loops may communicate.  It also offers a means by
     which a master event loop (the waiter or default event loop) may
     allocate work to worker event loops for execution.  It would be
     nice to have a pool of worker event loops for the purpose, but that
     is a work for the future.

     Depending on the circumstances, it may be desirable to provide
     throttling arguments when constructing the 'worker' event loop, in
     order to enable backpressure to be supplied if the 'worker' event
     loop becomes overloaded: see the documentation on the
     make-event-loop procedure for further information about that.
     (This procedure calls event-post!  in both the 'waiter' and
     'worker' event loops by the respective threads of the other, so
     either could be subject to throttling.)

     Exceptions may propagate out of this procedure if they arise while
     setting up, which shouldn't happen unless memory is exhausted or
     pthread has run out of resources.  Exceptions arising during
     execution of the task, if not caught locally, will propagate out of
     the event-loop-run!  procedure called for the 'worker' event loop.

     This procedure is first available in version 0.8 of this library.

     Here is an example of the use of await-task-in-event-loop!:
          (set-default-event-loop!)     ;; if none has yet been set
          (define worker (make-event-loop))
          (event-loop-block! #t)        ;; because the task runs in another thread
          (event-loop-block! #t worker)

          (call-with-new-thread
           (lambda ()
             (event-loop-run! worker)))

          (a-sync (lambda (await resume)
          	  (let ((res
          		 (await-task-in-event-loop! await resume worker
          					    (lambda ()
          					      (+ 5 10)))))
          	    (simple-format #t "~A\n" res)
          	    (event-loop-block! #f worker)
          	    (event-loop-block! #f))))
          (event-loop-run!)

 -- Scheme Procedure: await-task! await resume [loop] thunk
     The 'loop' argument is optional.  This is a convenience procedure
     for use with an event loop, which will run 'thunk' in the event
     loop specified by the 'loop' argument, or in the default event loop
     if no 'loop' argument is provided or #f is provided as the 'loop'
     argument.  This procedure calls 'await' and will return the thunk's
     return value.  It is intended to be called in a waitable procedure
     invoked by a-sync.  It is the single-threaded corollary of
     await-task-in-thread!.  This means that (unlike with
     await-task-in-thread!)  while 'thunk' is running other events in
     the event loop will not make progress, so blocking calls should not
     be made in 'thunk'.  This procedure can be useful for the purpose
     of implementing co-operative multi-tasking, say by composing tasks
     with compose-a-sync (see the *note compose: compose. module).

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     This procedure calls event-post!  in the event loop concerned.
     This is done in the same thread as that in which the event loop
     runs so it cannot of itself be throttled.  However it may
     contribute to the number of accumulated unexecuted tasks in the
     event loop and therefore contribute to the throttling of other
     threads by the loop.  See the documentation on the make-event-loop
     procedure for further information about that.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the task starts), which shouldn't
     happen unless memory is exhausted.  Exceptions arising during
     execution of the task, if not caught locally, will propagate out of
     event-loop-run!.

     Here is an example of the use of await-task!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (simple-format #t "1 + 1 is ~A\n"
          			 (await-task! await resume
          				      (lambda ()
          					(+ 1 1))))))
          (event-loop-run!)

 -- Scheme Procedure: await-generator-in-thread! await resume [loop]
          generator proc [handler]
     The 'loop' and 'handler' arguments are optional.  The 'generator'
     argument is a procedure taking one argument, namely a yield
     argument (see the documentation on the make-iterator procedure for
     further details).  This await-generator-in-thread!  procedure will
     run 'generator' in its own worker thread, and whenever 'generator'
     yields a value will cause 'proc' to execute in the event loop
     specified by the 'loop' argument (or in the default event loop if
     no 'loop' argument is provided or if #f is provided as the 'loop'
     argument - pattern matching is used to detect the type of the third
     argument).

     'proc' should be a procedure taking a single argument, namely the
     value yielded by the generator.  If the optional 'handler' argument
     is provided, then that handler will be run in the event loop thread
     if 'generator' throws; otherwise the program will terminate if an
     unhandled exception propagates out of 'generator'.  'handler'
     should take the same arguments as a guile catch handler (this is
     implemented using catch).

     This procedure calls 'await' and will return when the generator has
     finished or, if 'handler' is provided, upon the generator throwing
     an exception.  This procedure will return #f if the generator
     completes normally, or 'guile-a-sync-thread-error if the generator
     throws an exception and 'handler' is run (the
     'guile-a-sync-thread-error symbol is reserved to the implementation
     and should not be yielded by the generator).

     This procedure is intended to be called in a waitable procedure
     invoked by a-sync.  It will normally be necessary to call
     event-loop-block!  before invoking this procedure.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.  As mentioned
     above, the generator itself will run in its own thread.

     As the worker thread calls event-post!, it might be subject to
     throttling by the event loop concerned.  See the documentation on
     the make-event-loop procedure for further information about that.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the worker thread starts), which
     shouldn't happen unless memory is exhausted or pthread has run out
     of resources.  Exceptions arising during execution of the
     generator, if not caught by a handler procedure, will terminate the
     program.  Exceptions thrown by the handler procedure will propagate
     out of event-loop-run!.  Exceptions thrown by 'proc', if not caught
     locally, will also propagate out of event-loop-run!.

     This procedure is first available in version 0.9 of this library.

     Here is an example of the use of await-generator-in-thread!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
                    (await-generator-in-thread! await resume
          				      (lambda (yield)
          					(let loop ((count 0))
          					  (when (< count 5)
          					    (yield (* 2 count))
          					    (loop (1+ count)))))
          				      (lambda (val)
          					(display val)
          					(newline)))
          	  (event-loop-block! #f)))
          (event-loop-block! #t) ;; because the generator runs in another thread
          (event-loop-run!)

 -- Scheme Procedure: await-generator-in-event-loop! await resume
          [waiter] worker generator proc
     The 'waiter' argument is optional.  The 'worker' argument is an
     event loop running in a different thread than the one in which this
     procedure is called.  The 'generator' argument is a procedure
     taking one argument, namely a yield argument (see the documentation
     on the make-iterator procedure for further details).  This
     await-generator-in-event-loop!  procedure will cause 'generator' to
     run in the 'worker' event loop, and whenever 'generator' yields a
     value this will cause 'proc' to execute in the event loop specified
     by the 'waiter' argument, or in the default event loop if no
     'waiter' argument is provided or if #f is provided as the 'waiter'
     argument.  'proc' should be a procedure taking a single argument,
     namely the value yielded by the generator.

     This procedure is intended to be called in a waitable procedure
     invoked by a-sync.  It will normally be necessary to call
     event-loop-block!  on 'waiter' (or on the default event loop)
     before invoking this procedure.

     This procedure calls 'await' and will return when the generator has
     finished.  It must (like the a-sync procedure) be called in the
     same thread as that in which the 'waiter' or default event loop
     runs (as the case may be).

     This procedure acts, with await-task-in-event-loop!, as a form of
     channel through which two different event loops may communicate.
     It also offers a means by which a master event loop (the waiter or
     default event loop) may allocate work to worker event loops for
     execution.  It would be nice to have a pool of worker event loops
     for the purpose, but that is a work for the future.

     Depending on the circumstances, it may be desirable to provide
     throttling arguments when constructing the 'worker' event loop, in
     order to enable backpressure to be supplied if the 'worker' event
     loop becomes overloaded: see the documentation on the
     make-event-loop procedure for further information about that.
     (This procedure calls event-post!  in both the 'waiter' and
     'worker' event loops by the respective threads of the other, so
     either could be subject to throttling.)

     Exceptions may propagate out of this procedure if they arise while
     setting up, which shouldn't happen unless memory is exhausted or
     pthread has run out of resources.  Exceptions arising during
     execution of the generator, if not caught locally, will propagate
     out of the event-loop-run!  procedure called for the 'worker' event
     loop.  Exceptions arising during the execution of 'proc', if not
     caught locally, will propagate out of the event-loop-run!
     procedure called for the 'waiter' or default event loop (as the
     case may be).

     This procedure is first available in version 0.9 of this library.

     Here is an example of the use of await-generator-in-event-loop!:
          (set-default-event-loop!)     ;; if none has yet been set
          (define worker (make-event-loop))
          (event-loop-block! #t)        ;; because the generator runs in another thread
          (event-loop-block! #t worker)

          (call-with-new-thread
           (lambda ()
             (event-loop-run! worker)))

          (a-sync (lambda (await resume)
          	  (await-generator-in-event-loop! await resume worker
          					  (lambda (yield)
          					    (let loop ((count 0))
          					      (when (< count 5)
          						(yield (* 2 count))
          						(loop (1+ count)))))
          					  (lambda (val)
          					    (display val)
          					    (newline)))
          	  (event-loop-block! #f worker)
          	  (event-loop-block! #f)))
          (event-loop-run!)

 -- Scheme Procedure: await-generator! await resume [loop] generator
          proc
     The 'loop' argument is optional.  The 'generator' argument is a
     procedure taking one argument, namely a yield argument (see the
     documentation on the make-iterator procedure for further details).
     This await-generator!  procedure will run 'generator', and whenever
     'generator' yields a value will cause 'proc' to execute in the
     event loop specified by the 'loop' argument, or in the default
     event loop if no 'loop' argument is provided or #f is provided as
     the 'loop' argument.  'proc' should be a procedure taking a single
     argument, namely the value yielded by the generator.  Each time
     'proc' runs it will do so as a separate event in the event loop and
     so be multi-plexed with other events.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     This procedure is intended to be called in a waitable procedure
     invoked by a-sync.  It is the single-threaded corollary of
     await-generator-in-thread!.  This means that (unlike with
     await-generator-in-thread!)  while 'generator' is running other
     events in the event loop will not make progress, so blocking calls
     (other than to the yield procedure) should not be made in
     'generator'.  This procedure can be useful for the purpose of
     implementing co-operative multi-tasking, say by composing tasks
     with compose-a-sync (see compose.scm).

     This procedure calls event-post!  in the event loop concerned.
     This is done in the same thread as that in which the event loop
     runs so it cannot of itself be throttled.  However it may
     contribute to the number of accumulated unexecuted tasks in the
     event loop and therefore contribute to the throttling of other
     threads by the loop.  See the documentation on the make-event-loop
     procedure for further information about that.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the task starts), which shouldn't
     happen unless memory is exhausted.  Exceptions arising during
     execution of the generator, if not caught locally, will propagate
     out of await-generator!.  Exceptions thrown by 'proc', if not
     caught locally, will propagate out of event-loop-run!.

     This procedure is first available in version 0.9 of this library.

     Here is an example of the use of await-generator!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (await-generator! await resume
          			    (lambda (yield)
          			      (let loop ((count 0))
          				(when (< count 5)
          				  (yield (* 2 count))
          				  (loop (1+ count)))))
          			    (lambda (val)
          			      (display val)
          			      (newline)))))
          (event-loop-run!)

 -- Scheme Procedure: await-timeout! await resume [loop] msecs thunk
     This is a convenience procedure for use with an event loop, which
     will run 'thunk' in the event loop thread when the timeout expires.
     This procedure calls 'await' and will return the thunk's return
     value.  It is intended to be called in a waitable procedure invoked
     by a-sync.  The timeout is single shot only - as soon as 'thunk'
     has run once and completed, the timeout will be removed from the
     event loop.  The 'loop' argument is optional: this procedure
     operates on the event loop passed in as an argument, or if none is
     passed (or #f is passed), on the default event loop.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the first call to 'await' is made),
     which shouldn't happen unless memory is exhausted.  Exceptions
     thrown by 'thunk', if not caught locally, will propagate out of
     event-loop-run!.

     Here is an example of the use of event-timeout!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (simple-format #t
          			 "Timeout ~A\n"
          			 (await-timeout! await resume
          					 100
          					 (lambda ()
          					   "expired")))))
          (event-loop-run!)

 -- Scheme Procedure: a-sync-read-watch! resume file proc [loop]
     This is a convenience procedure for use with an event loop, which
     will run 'proc' in the event loop thread whenever 'file' is ready
     for reading, and apply 'resume' (obtained from a call to a-sync) to
     the return value of 'proc'.  'file' can be a port or a file
     descriptor (and if it is a file descriptor, the revealed count is
     not incremented).  'proc' should take a single argument which will
     be set by the event loop to 'in or 'excpt (see the documentation on
     event-loop-add-read-watch!  for further details).  It is intended
     to be called in a waitable procedure invoked by a-sync.  The watch
     is multi-shot - it is for the user to bring it to an end at the
     right time by calling event-loop-remove-read-watch!  in the
     waitable procedure.  If 'file' is a buffered port, buffering will
     be taken into account in indicating whether a read can be made
     without blocking (but on a buffered port, for efficiency purposes
     each read operation in response to this watch should usually
     exhaust the buffer by calling drain-input or by looping on
     char-ready?).

     This procedure is mainly intended as something from which
     higher-level asynchronous file operations can be constructed, such
     as the await-readline!  procedure.  The 'loop' argument is
     optional: this procedure operates on the event loop passed in as an
     argument, or if none is passed (or #f is passed), on the default
     event loop

     Because this procedure takes a 'resume' argument derived from the
     a-sync procedure, it must (like the a-sync procedure) in practice
     be called in the same thread as that in which the event loop runs.

     This procedure should not throw an exception unless memory is
     exhausted.  If 'proc' throws, say because of port errors, and the
     exception is not caught locally, it will propagate out of
     event-loop-run!.

     As an example of how to use a-sync-read-watch!, here is the
     implementation of await-getline!:
          (define await-getline!
             (case-lambda
              ((await resume port)
               (await-getline! await resume #f port))
              ((await resume loop port)
               (let ()
                 (define chunk-size 128)
                 (define text (make-bytevector chunk-size))
                 (define text-len 0)
                 (define (append-byte! u8)
          	 (when (= text-len (bytevector-length text))
          	   (let ((tmp text))
          	     (set! text (make-bytevector (+ text-len chunk-size)))
          	     (bytevector-copy! tmp 0 text 0 text-len)))
          	 (bytevector-u8-set! text text-len u8)
          	 (set! text-len (1+ text-len)))
                 (define (make-outstring)
          	 (let ((encoding (or (port-encoding port)
          			     (fluid-ref %default-port-encoding)
          			     "ISO-8859-1"))
          	       (conversion-strategy (port-conversion-strategy port))
          	       (out-bv (make-bytevector text-len)))
          	   (bytevector-copy! text 0 out-bv 0 text-len)
          	   (iconv:bytevector->string out-bv encoding conversion-strategy)))
                 (a-sync-read-watch! resume
          			   port
          			   (lambda (status)
          			     (if (eq? status 'excpt)
          				 #f
          				 (let next ()
          				   (let ((u8
          					  (catch 'system-error
          					    (lambda ()
          					      (get-u8 port))
          					    (lambda args
          					      (if (or (= EAGAIN (system-error-errno args))
          						      (and (defined? 'EWOULDBLOCK)
          							   (= EWOULDBLOCK (system-error-errno args))))
          						  'more
          						  (apply throw args))))))
          				     (cond
          				      ((eq? u8 'more)
          				       'more)
          				      ((eof-object? u8)
          				       (if (= text-len 0)
          					   u8
          					   (make-outstring)))
          				      ((= u8 (char->integer #\return))
          				       (if (char-ready? port)
          					   (next)
          					   'more))
          				      ((= u8 (char->integer #\newline))
          				       (make-outstring))
          				      (else
          				       (append-byte! u8)
          				       (if (char-ready? port)
          					   (next)
          					   'more)))))))
          			   loop))
               (let next ((res (await)))
                 (if (eq? res 'more)
          	   (next (await))
          	   (begin
          	     (event-loop-remove-read-watch! port loop)
          	     res))))))

 -- Scheme Procedure: await-getline! await resume [loop] port
     This is a convenience procedure for use with an event loop, which
     will start a read watch on 'port' for a line of input.  It calls
     'await' while waiting for input and will return the line of text
     received (without the terminating '\n' character).  The event loop
     will not be blocked by this procedure even if only individual
     characters are available at any one time.  It is intended to be
     called in a waitable procedure invoked by a-sync, and this
     procedure is implemented using a-sync-read-watch!.  If an
     exceptional condition ('excpt) is encountered, #f will be returned.
     If an end-of-file object is encountered which terminates a line of
     text, a string containing the line of text will be returned (and
     from version 0.3, if an end-of-file object is encountered without
     any text, the end-of-file object is returned rather than an empty
     string).  The 'loop' argument is optional: this procedure operates
     on the event loop passed in as an argument, or if none is passed
     (or #f is passed), on the default event loop.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the first call to 'await' is made),
     which shouldn't happen unless memory is exhausted.  Subsequent
     exceptions (say, because of port or conversion errors) will
     propagate out of event-loop-run!.

     From version 0.6, the bytes comprising the input text will be
     converted to their string representation using the encoding of
     'port' if a port encoding has been set, or otherwise using the
     program's default port encoding, or if neither has been set using
     iso-8859-1 (Latin-1).  Exceptions from conversion errors will, as
     mentioned, propagate out of event-loop-run!.  Conversion errors
     should not arise with iso-8859-1 encoding, although the string may
     not necessarily have the desired meaning for the program concerned
     if the input encoding is in fact different.  From version 0.7, this
     procedure uses the conversion strategy for 'port' (which defaults
     at program start-up to 'substitute); version 0.6 instead always
     used a conversion strategy of 'error if encountering unconvertible
     characters).

     From version 0.6, this procedure may be used with an end-of-line
     representation of either a line-feed (\n) or a carriage-return and
     line-feed (\r\n) combination, as from version 0.6 any carriage
     return byte will be discarded (this did not occur with earlier
     versions).

     Here is an example of the use of await-getline!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (display "Enter a line of text at the keyboard\n")
          	  (simple-format #t
          			 "The line was: ~A\n"
          			 (await-getline! await resume
          					 (open "/dev/tty" O_RDONLY)))))
          (event-loop-run!)

 -- Scheme Procedure: await-geteveryline! await resume [loop] port proc
     This is a convenience procedure for use with an event loop, which
     will start a read watch on 'port' for lines of input.  It calls
     'await' while waiting for input and will apply 'proc' to every
     complete line of text received (without the terminating '\n'
     character).  'proc' should be a procedure taking a string as its
     only argument.

     The event loop will not be blocked by this procedure even if only
     individual characters are available at any one time.  It is
     intended to be called in a waitable procedure invoked by a-sync,
     and this procedure is implemented using a-sync-read-watch!.  Unlike
     the await-getline!  procedure, the watch will continue after a line
     of text has been received in order to receive further lines.  The
     watch will not end until end-of-file or an exceptional condition
     ('excpt) is reached.  In the event of that happening, this
     procedure will end and return an end-of-file object or #f
     respectively.

     The 'loop' argument is optional: this procedure operates on the
     event loop passed in as an argument, or if none is passed (or #f is
     passed), on the default event loop.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the first call to 'await' is made),
     which shouldn't happen unless memory is exhausted.  Subsequent
     exceptions (say, because of port or conversion errors) will
     propagate out of event-loop-run!.  Exceptions thrown by 'proc', if
     not caught locally, will also propagate out of event-loop-run!.

     This procedure is available from version 0.3.  From version 0.6,
     the bytes comprising the input text will be converted to their
     string representation using the encoding of 'port' if a port
     encoding has been set, or otherwise using the program's default
     port encoding, or if neither has been set using iso-8859-1
     (Latin-1).  Exceptions from conversion errors will, as mentioned,
     propagate out of event-loop-run!.  Conversion errors should not
     arise with iso-8859-1 encoding, although strings may not
     necessarily have the desired meaning for the program concerned if
     the input encoding is in fact different.  From version 0.7, this
     procedure uses the conversion strategy for 'port' (which defaults
     at program start-up to 'substitute); version 0.6 instead always
     used a conversion strategy of 'error if encountering unconvertible
     characters).

     From version 0.6, this procedure may be used with an end-of-line
     representation of either a line-feed (\n) or a carriage-return and
     line-feed (\r\n) combination, as from version 0.6 any carriage
     return byte will be discarded (this did not occur with earlier
     versions).

     Here is an example of the use of await-geteveryline!  (because the
     keyboard has no end-of-file, use Ctrl-C to exit this code snippet):
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (display "Enter lines of text at the keyboard, ^C to finish\n")
          	  (let ((port (open "/dev/tty" O_RDONLY)))
          	    (await-geteveryline! await resume
          				 port
          				 (lambda (line)
          				   (simple-format #t
          						  "The line was: ~A\n"
          						  line))))))
          (event-loop-run!)

 -- Scheme Procedure: await-getsomelines! await resume [loop] port proc
     This is a convenience procedure for use with an event loop, which
     does the same as await-geteveryline!, except that it provides a
     second argument to 'proc', namely an escape continuation which can
     be invoked by 'proc' to cause the procedure to return before
     end-of-file is reached.  Behavior is identical to
     await-geteveryline!  if the continuation is not invoked.

     This procedure will start a read watch on 'port' for lines of
     input.  It calls 'await' while waiting for input and will apply
     'proc' to any complete line of text received (without the
     terminating '\n' character).  'proc' should be a procedure taking
     two arguments, a string as the first argument containing the line
     of text read, and an escape continuation as its second.

     The event loop will not be blocked by this procedure even if only
     individual characters are available at any one time.  It is
     intended to be called in a waitable procedure invoked by a-sync.
     This procedure is implemented using a-sync-read-watch!.  The watch
     will not end until end-of-file or an exceptional condition ('excpt)
     is reached, which would cause this procedure to end and return an
     end-of-file object or #f respectively, or until the escape
     continuation is invoked, in which case the value passed to the
     escape continuation will be returned.

     The 'loop' argument is optional: this procedure operates on the
     event loop passed in as an argument, or if none is passed (or #f is
     passed), on the default event loop.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the first call to 'await' is made),
     which shouldn't happen unless memory is exhausted.  Subsequent
     exceptions (say, because of port or conversion errors) will
     propagate out of event-loop-run!.  Exceptions thrown by 'proc', if
     not caught locally, will also propagate out of event-loop-run!.

     This procedure is available from version 0.4.  From version 0.6,
     the bytes comprising the input text will be converted to their
     string representation using the encoding of 'port' if a port
     encoding has been set, or otherwise using the program's default
     port encoding, or if neither has been set using iso-8859-1
     (Latin-1).  Exceptions from conversion errors will, as mentioned,
     propagate out of event-loop-run!.  Conversion errors should not
     arise with iso-8859-1 encoding, although strings may not
     necessarily have the desired meaning for the program concerned if
     the input encoding is in fact different.  From version 0.7, this
     procedure uses the conversion strategy for 'port' (which defaults
     at program start-up to 'substitute); version 0.6 instead always
     used a conversion strategy of 'error if encountering unconvertible
     characters).

     From version 0.6, this procedure may be used with an end-of-line
     representation of either a line-feed (\n) or a carriage-return and
     line-feed (\r\n) combination, as from version 0.6 any carriage
     return byte will be discarded (this did not occur with earlier
     versions).

     Here is an example of the use of await-getsomelines!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (display "Enter lines of text at the keyboard, enter an empty line to finish\n")
          	  (let ((port (open "/dev/tty" O_RDONLY)))
          	    (await-getsomelines! await resume
          				 port
          				 (lambda (line k)
                                             (when (string=? line "")
          					 (k #f))
          				   (simple-format #t
          						  "The line was: ~A\n"
          						  line))))))
          (event-loop-run!)

 -- Scheme Procedure: a-sync-write-watch! resume file proc [loop]
     This is a convenience procedure for use with an event loop, which
     will run 'proc' in the event loop thread whenever 'file' is ready
     for writing, and apply 'resume' (obtained from a call to a-sync) to
     the return value of 'proc'.  'file' can be a port or a file
     descriptor (and if it is a file descriptor, the revealed count is
     not incremented).  'proc' should take a single argument which will
     be set by the event loop to 'out or 'excpt (see the documentation
     on event-loop-add-write-watch!  for further details).  It is
     intended to be called in a waitable procedure invoked by a-sync.
     The watch is multi-shot - it is for the user to bring it to an end
     at the right time by calling event-loop-remove-write-watch!  in the
     waitable procedure.  This procedure is mainly intended as something
     from which higher-level asynchronous file operations can be
     constructed.  The 'loop' argument is optional: this procedure
     operates on the event loop passed in as an argument, or if none is
     passed (or #f is passed), on the default event loop

     The documentation on the event-loop-add-write-watch!  procedure
     explains why this procedure generally works best with an unbuffered
     port.

     Because this procedure takes a 'resume' argument derived from the
     a-sync procedure, it must (like the a-sync procedure) in practice
     be called in the same thread as that in which the event loop runs.

     This procedure should not throw an exception unless memory is
     exhausted.  If 'proc' throws, say because of port errors, and the
     exception is not caught locally, it will propagate out of
     event-loop-run!.

     As an example of how to use a-sync-write-watch!, here is the
     implementation of await-put-string!:
          (define await-put-string!
            (case-lambda
              ((await resume port text) (await-put-string! await resume #f port text))
              ((await resume loop port text)
               (define index 0)
               (define bv
                 (let ((encoding (or (port-encoding port)
          			   (fluid-ref %default-port-encoding)
          			   "ISO-8859-1"))
          	     (conversion-strategy (port-conversion-strategy port)))
          	 (iconv:string->bytevector text encoding conversion-strategy)))
               (define length (bytevector-length bv))
               (a-sync-write-watch! resume
          			  port
          			  (lambda (status)
          			    (if (eq? status 'excpt)
          				#f
          				(catch 'system-error
          				  (lambda ()
          				    (let next ()
          				      (if (= index length)
          					  #t
          					  (begin
          					    (put-u8 port (bytevector-u8-ref bv index))
          					    (set! index (1+ index))
          					    (next)))))
          				  (lambda args
          				    (if (or (= EAGAIN (system-error-errno args))
          					    (and (defined? 'EWOULDBLOCK)
          						 (= EWOULDBLOCK (system-error-errno args))))
          					'more
          					(apply throw args))))))
          			  loop)
               (let next ((res (await)))
                 (if (eq? res 'more)
          	   (next (await))
          	   (begin
          	     (event-loop-remove-write-watch! port loop)
          	     res))))))

 -- Scheme Procedure: await-put-string! await resume [loop] port text
     This is a convenience procedure for use in an event loop, which
     will start a write watch on 'port' for writing a string to the
     port.  It calls 'await' while waiting for output to become
     available.  Provided 'port' is a non-blocking port, the event loop
     will not be blocked by this procedure even if only individual
     characters can be written at any one time.  It is intended to be
     called in a waitable procedure invoked by a-sync, and this
     procedure is implemented using a-sync-write-watch!.  If an
     exceptional condition ('excpt) is encountered, #f will be returned,
     otherwise #t will be returned (but an exceptional condition should
     never be encountered on an output port).  The 'loop' argument is
     optional: this procedure operates on the event loop passed in as an
     argument, or if none is passed (or #f is passed), on the default
     event loop.

     'port' must be a non-blocking port, or this procedure may block the
     event loop when writing.  It can be made non-blocking with this:

          (fcntl [port] F_SETFL (logior O_NONBLOCK
                                (fcntl [port] F_GETFL)))

     In addition, it should be unbuffered (say by using the open-file,
     fdopen or duplicate-port procedure with the '0' mode option, or by
     calling setvbuf), or any buffer flushing operation may also block.
     In consequence, if a lot of text is to be passed, it may be worth
     checking whether using conventional buffered blocking output in a
     task started by await-task-in-thread!  or await-task-in-event-loop!
     offers better performance.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the first call to 'await' is made),
     which shouldn't happen unless memory is exhausted or a conversion
     error is encountered.  Subsequent exceptions (say, because of port
     errors) will propagate out of event-loop-run!.

     The bytes to be sent will be converted from the passed in string
     representation using the encoding of 'port' if a port encoding has
     been set, or otherwise using the program's default port encoding,
     or if neither has been set using iso-8859-1 (Latin-1).  Exceptions
     from conversion errors will propagate out of this procedure when
     setting up if conversion fails and a conversion strategy of 'error
     is in effect.  This procedure uses the conversion strategy for
     'port' (which defaults at program start-up to 'substitute).

     If CR-LF line endings are to be written when outputting the string,
     the '\r' character (as well as the '\n' character) must be embedded
     in the string.

     This procedure is first available in version 0.10 of this library.

     An example of the use of this procedure can be found in the
     example-socket.scm file in the docs directory.

   The (a-sync event-loop) module also loads the *note (a-sync
monotonic-time): monotonic time. module.


File: guile-a-sync.info,  Node: monotonic time,  Next: gnome glib,  Prev: event loop,  Up: Top

The (a-sync monotonic-time) module provides two procedures.  It is
loaded by the *note (a-sync event-loop): event loop. module.

 -- Scheme Procedure: have-monotonic-time?
     This procedure indicates whether the get-time procedure (see below)
     provides a monotonic clock.  Almost all modern linux/unix-like
     systems will do so.  This procedure may return #f if windows is in
     use, or if the guile-a-sync library was cross-compiled on one
     architecture for a different one.

 -- Scheme Procedure: get-time
     This returns the current time as a (secs .  usecs) pair from some
     arbitrary epoch.  If (have-monotonic-time) returns #t, then this
     will be derived from a monotonic clock obtained by calling the
     clock_gettime() POSIX function with a CLOCK_MONOTONIC argument.
     This procedure is used by the *note event-loop: event loop. timeout
     implementation.  This procedure throws an 'a-sync-exception (which
     would propagate out of the event-loop-run!  procedure if *note
     event-loop: event loop. is in use) if the library has been
     configured for monotonic time at configuration time but it is not
     in fact supported.  However this is not worth catering for by user
     code as it should never happen - the library configuration macros
     should always give the correct answer


File: guile-a-sync.info,  Node: gnome glib,  Next: compose,  Prev: monotonic time,  Up: Top

When using the scheme (gnome gtk) bindings of guile-gnome with guile, in
order to provide await semantics on gtk+ callbacks it will normally be
necessary to use the 'await' and 'resume' procedures provided by the
a-sync procedure in the *note (a-sync coroutines): coroutines. module
directly (calling 'resume' in the gtk+ callback when ready, and waiting
on that callback using 'await').  However when launching timeouts, file
watches or idle events on the glib main loop, convenience procedures are
possible similar to those provided for the event loop in the *note
(a-sync event-loop): event loop. module.  These are set out below.

   Note that the g-idle-add procedure in guile-gnome is suspect - there
appears to be a garbage collection issue, and if you call the procedure
often enough in a single or multi-threaded program it will eventually
segfault.  g-io-add-watch is also broken in guile-gnome, so this library
uses its own glib-add-watch procedure which is exported publicly in case
it is useful to users.

   All the other scheme files provided by this library are by default
compiled by this library to bytecode.  That is not the case with this
module, so as not to create a hard dependency on guile-gnome.

   The (a-sync gnome-glib) module provides the following procedures:

 -- Scheme Procedure: await-glib-task-in-thread await resume thunk
          [handler]
     This is a convenience procedure which will run 'thunk' in its own
     thread, and then post an event to the default glib main loop when
     'thunk' has finished.  This procedure calls 'await' in the default
     glib main loop and will return the thunk's return value.  It is
     intended to be called in a waitable procedure invoked by a-sync.
     If the optional 'handler' argument is provided, then it will be run
     in the default glib main loop if 'thunk' throws and its return
     value will be the return value of this procedure; otherwise the
     program will terminate if an unhandled exception propagates out of
     'thunk'.  'handler' should take the same arguments as a guile catch
     handler (this is implemented using catch).

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the default glib main loop runs, where
     the result of calling 'thunk' will be received.  As mentioned
     above, the thunk itself will run in its own thread.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the worker thread starts), which
     shouldn't happen unless memory is exhausted or pthread has run out
     of resources.  Exceptions arising during execution of the task, if
     not caught by a handler procedure, will terminate the program.
     Exceptions thrown by the handler procedure will propagate out of
     g-main-loop-run.

     This procedure uses g-idle-add: see the introductory remarks about
     that.

     Here is an example of the use of await-glib-task-in-thread:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (simple-format #t "1 + 1 is ~A\n"
          			 (await-glib-task-in-thread await resume
          						    (lambda ()
          						      (+ 1 1))))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-task await resume thunk
     This is a convenience procedure for use with glib, which will run
     'thunk' in the default glib main loop.  This procedure calls
     'await' and will return the thunk's return value.  It is intended
     to be called in a waitable procedure invoked by a-sync.  It is the
     single-threaded corollary of await-glib-task-in-thread.  This means
     that (unlike with await-glib-task-in-thread) while 'thunk' is
     running other events in the main loop will not make progress, so
     blocking calls should not be made in 'thunk'.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the default glib main loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the task starts), which shouldn't
     happen unless memory is exhausted.  Exceptions arising during
     execution of the task, if not caught locally, will propagate out of
     g-main-loop-run.

     This procedure uses g-idle-add: see the introductory remarks about
     that.

     Here is an example of the use of await-glib-task:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (simple-format #t "1 + 1 is ~A\n"
          			 (await-glib-task await resume
          					  (lambda ()
          					    (+ 1 1))))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-generator-in-thread await resume
          generator proc [handler]
     This is a convenience procedure for acting asynchronously on values
     yielded by generator procedures.  The 'generator' argument is a
     procedure taking one argument, namely a yield argument (see the
     documentation on the make-iterator procedure for further details).
     This await-glib-generator-in-thread procedure will run 'generator'
     in its own worker thread, and whenever 'generator' yields a value
     will cause 'proc' to execute in the default glib main loop.

     'proc' should be a procedure taking a single argument, namely the
     value yielded by the generator.  If the optional 'handler' argument
     is provided, then that handler will be run in the default glib main
     loop if 'generator' throws; otherwise the program will terminate if
     an unhandled exception propagates out of 'generator'.  'handler'
     should take the same arguments as a guile catch handler (this is
     implemented using catch).

     This procedure calls 'await' and will return when the generator has
     finished or, if 'handler' is provided, upon the generator throwing
     an exception.  This procedure will return #f if the generator
     completes normally, or 'guile-a-sync-thread-error if the generator
     throws an exception and 'handler' is run (the
     'guile-a-sync-thread-error symbol is reserved to the implementation
     and should not be yielded by the generator).

     This procedure is intended to be called in a waitable procedure
     invoked by a-sync.  It must (like the a-sync procedure) be called
     in the same thread as that in which the default glib main loop
     runs.  As mentioned above, the generator itself will run in its own
     thread.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the worker thread starts), which
     shouldn't happen unless memory is exhausted or pthread has run out
     of resources.  Exceptions arising during execution of the
     generator, if not caught by a handler procedure, will terminate the
     program.  Exceptions thrown by the handler procedure will propagate
     out of g-main-loop-run.  Exceptions thrown by 'proc', if not caught
     locally, will also propagate out of g-main-loop-run!.

     This procedure is first available in version 0.9 of this library.

     This procedure uses g-idle-add: see the introductory remarks about
     that.

     Here is an example of the use of await-glib-generator-in-thread:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (await-glib-generator-in-thread await resume
          					  (lambda (yield)
          					    (let loop ((count 0))
          					      (when (< count 5)
          						(yield (* 2 count))
          						(loop (1+ count)))))
          					  (lambda (val)
          					    (display val)
          					    (newline)))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-generator await resume generator proc
     This is a convenience procedure for acting asynchronously on values
     yielded by generator procedures.  The 'generator' argument is a
     procedure taking one argument, namely a yield argument (see the
     documentation on the make-iterator procedure for further details).
     This await-glib-generator procedure will run 'generator', and
     whenever 'generator' yields a value will cause 'proc' to execute in
     the default glib main loop - each time 'proc' runs it will do so as
     a separate event in the main loop and so be multi-plexed with other
     events.  'proc' should be a procedure taking a single argument,
     namely the value yielded by the generator.

     This procedure is intended to be called in a waitable procedure
     invoked by a-sync.  It is the single-threaded corollary of
     await-glib-generator-in-thread.  This means that (unlike with
     await-glib-generator-in-thread) while 'generator' is running other
     events in the main loop will not make progress, so blocking calls
     (other than to the yield procedure) should not be made in
     'generator'.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the task starts), which shouldn't
     happen unless memory is exhausted.  Exceptions arising during
     execution of the generator, if not caught locally, will propagate
     out of await-glib-generator.  Exceptions thrown by 'proc', if not
     caught locally, will propagate out of g-main-loop-run!.

     This procedure is first available in version 0.9 of this library.

     This procedure uses g-idle-add: see the introductory remarks about
     that.

     Here is an example of the use of await-glib-generator:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (await-glib-generator await resume
          				(lambda (yield)
          				  (let loop ((count 0))
          				    (when (< count 5)
          				      (yield (* 2 count))
          				      (loop (1+ count)))))
          				(lambda (val)
          				  (display val)
          				  (newline)))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-timeout await resume msecs thunk
     This is a convenience procedure for use with a glib main loop,
     which will run 'thunk' in the default glib main loop when the
     timeout expires.  This procedure calls 'await' and will return the
     thunk's return value.  It is intended to be called in a waitable
     procedure invoked by a-sync.  The timeout is single shot only - as
     soon as 'thunk' has run once and completed, the timeout will be
     removed from the event loop.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the default glib main loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the first call to 'await' is made),
     which shouldn't happen unless memory is exhausted.  Exceptions
     thrown by 'thunk', if not caught locally, will propagate out of
     g-main-loop-run.

     Here is an example of the use of await-glib-timeout:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (simple-format #t
          			 "Timeout ~A\n"
          			 (await-glib-timeout await resume
          					     100
          					     (lambda ()
          					       "expired")))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: glib-add-watch ioc cond func [context]
     This procedure replaces guile-gnome's g-io-add-watch procedure,
     which won't compile.  It attaches a watch on a g-io-channel object
     to the main context provided, or if none is provided, to the
     default glib main context (the main program loop).  It returns a
     glib ID which can be passed subsequently to the g-source-remove
     procedure.  It should be possible to call this procedure in any
     thread.

     'ioc' is the g-io-condition object to which the watch is to be
     attached, and 'cond' is a list of symbols (being 'in, 'out, 'pri,
     'hup, 'err and 'nval) comprising the events for which the watch is
     established.

     'func' is executed when an event occurs, and takes two arguments:
     first the g-io-channel object to which the watch has been attached,
     and second a g-io-condition object indicating the watch condition
     which has been met (note: the interface for g-io-condition objects
     is broken in guile-gnome at present).  The watch is ended either by
     'func' returning #f, or by applying g-source-remove to the return
     value of this procedure.  Otherwise the watch will continue.

     See the documentation on the a-sync-glib-read-watch procedure for
     some of the difficulties with using g-io-channel watches with
     guile-gnome.

 -- Scheme Procedure: a-sync-glib-read-watch resume fd proc
     This is a convenience procedure for use with a glib main loop,
     which will run 'proc' in the default glib main loop whenever the
     file descriptor 'fd' is ready for reading, and apply resume
     (obtained from a call to a-sync) to the return value of 'proc'.
     'proc' should take two arguments, the first of which will be set by
     glib to the g-io-channel object constructed for the watch and the
     second of which will be set to the GIOCondition ('in, 'hup or 'err)
     provided by glib which caused the watch to activate.  It is
     intended to be called in a waitable procedure invoked by a-sync.
     The watch is multi-shot - it is for the user to bring it to an end
     at the right time by calling g-source-remove in the waitable
     procedure on the id tag returned by this procedure.  Any port for
     the file descriptor 'fd' is not referenced for garbage collection
     purposes - it must remain valid while the read watch is active.
     This procedure is mainly intended as something from which
     higher-level asynchronous file operations can be constructed, such
     as the await-glib-getline procedure.

     File watches in guile-gnome are implemented using a GIOChannel
     object, and unfortunately GIOChannel support in guile-gnome is
     decaying.  The only procedure that guile-gnome provides to read
     from a GIOChannel object is g-io-channel-read-line, which does not
     work.  One is therefore usually left with having to read from a
     guile port (whose underlying file descriptor is 'fd') using guile's
     port input procedures, but this has its own difficulties because
     either (i) the port has to be unbuffered (say by using the
     open-file or fdopen procedure with the '0' mode option or the R6RS
     open-file-input-port procedure with a buffer-mode of none, or by
     calling setvbuf), or (ii) 'proc' must deal with everything in the
     port's buffer by calling drain-input, or by looping on char-ready?
     before returning.  This is because otherwise, if the port is
     buffered, once the port is read from there may be further
     characters in the buffer to be dealt with even though the
     GIOChannel watch does not trigger because there is nothing new to
     make the file descriptor ready for reading.

     Because this procedure takes a 'resume' argument derived from the
     a-sync procedure, it must (like the a-sync procedure) in practice
     be called in the same thread as that in which the default glib main
     loop runs.

     This procedure should not throw an exception unless memory is
     exhausted, or guile-glib throws for some other reason.  If 'proc'
     throws, say because of port errors, and the exception is not caught
     locally, it will propagate out of g-main-loop-run.

     As an example of how to use a-sync-glib-read-watch, here is the
     implementation of await-glib-getline:
          (define (await-glib-getline await resume port)
            (define chunk-size 128)
            (define text (make-bytevector chunk-size))
            (define text-len 0)
            (define (append-byte! u8)
              (when (= text-len (bytevector-length text))
                (let ((tmp text))
          	(set! text (make-bytevector (+ text-len chunk-size)))
          	(bytevector-copy! tmp 0 text 0 text-len)))
              (bytevector-u8-set! text text-len u8)
              (set! text-len (1+ text-len)))
            (define (make-outstring)
              (let ((encoding (or (port-encoding port)
          			(fluid-ref %default-port-encoding)
          			"ISO-8859-1"))
          	  (conversion-strategy (port-conversion-strategy port))
          	  (out-bv (make-bytevector text-len)))
                (bytevector-copy! text 0 out-bv 0 text-len)
                (iconv:bytevector->string out-bv encoding conversion-strategy)))
            (define id (a-sync-glib-read-watch resume
          				     (port->fdes port)
          				     (lambda (ioc status)
          				       (let next ()
          					 (let ((u8
          						(catch 'system-error
          						  (lambda ()
          						    (get-u8 port))
          						  (lambda args
          						    (if (or (= EAGAIN (system-error-errno args))
          							    (and (defined? 'EWOULDBLOCK)
          								 (= EWOULDBLOCK (system-error-errno args))))
          							'more
          							(apply throw args))))))
          					   (cond
          					    ((eq? u8 'more)
          					     'more)
          					    ((eof-object? u8)
          					     (if (= text-len 0)
          						 u8
          						 (make-outstring)))
          					    ((= u8 (char->integer #\return))
          					     (if (char-ready? port)
          						 (next)
          						 'more))
          					    ((= u8 (char->integer #\newline))
          					     (make-outstring))
          					    (else
          					     (append-byte! u8)
          					     (if (char-ready? port)
          						 (next)
          						 'more))))))))
            (let next ((res (await)))
              (if (eq? res 'more)
          	(next (await))
          	(begin
          	  (g-source-remove id)
          	  (release-port-handle port)
          	  res))))

 -- Scheme Procedure: await-glib-getline await resume port
     This is a convenience procedure for use with a glib main loop,
     which will start a read watch on 'port' for a line of input.  It
     calls 'await' while waiting for input and will return the line of
     text received (without the terminating '\n' character).  The event
     loop will not be blocked by this procedure even if only individual
     characters are available at any one time.  It is intended to be
     called in a waitable procedure invoked by a-sync, and this
     procedure is implemented using a-sync-glib-read-watch.  If an
     end-of-file object is encountered which terminates a line of text,
     a string containing the line of text will be returned (and from
     version 0.3, if an end-of-file object is encountered without any
     text, the end-of-file object is returned rather than an empty
     string).

     For the reasons explained in the documentation on
     a-sync-glib-read-watch, this procedure only works correctly if the
     port passed to the 'port' argument has buffering switched off (say
     by using the open-file, fdopen or duplicate-port procedure with the
     '0' mode option, or by calling setvbuf).  This makes the procedure
     less useful than would otherwise be the case.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the default glib main loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the first call to 'await' is made),
     which shouldn't happen unless memory is exhausted.  Subsequent
     exceptions (say, because of port or conversion errors) will
     propagate out of g-main-loop-run.

     From version 0.6, the bytes comprising the input text will be
     converted to their string representation using the encoding of
     'port' if a port encoding has been set, or otherwise using the
     program's default port encoding, or if neither has been set using
     iso-8859-1 (Latin-1).  Exceptions from conversion errors will, as
     mentioned, propagate out of g-main-loop-run.  Conversion errors
     should not arise with iso-8859-1 encoding, although the string may
     not necessarily have the desired meaning for the program concerned
     if the input encoding is in fact different.  From version 0.7, this
     procedure uses the conversion strategy for 'port' (which defaults
     at program start-up to 'substitute); version 0.6 instead always
     used a conversion strategy of 'error if encountering unconvertible
     characters).

     From version 0.6, this procedure may be used with an end-of-line
     representation of either a line-feed (\n) or a carriage-return and
     line-feed (\r\n) combination, as from version 0.6 any carriage
     return byte will be discarded (this did not occur with earlier
     versions).

     Here is an example of the use of await-glib-getline:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
                    (display "Enter a line of text at the keyboard\n")
                    (simple-format #t
                                   "The line was: ~A\n"
                                   (await-glib-getline await resume
          					     (open-file-input-port "/dev/tty" (file-options) (buffer-mode none))))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: a-sync-glib-write-watch resume fd proc
     This is a convenience procedure for use with a glib main loop,
     which will run 'proc' in the default glib main loop whenever the
     file descriptor 'fd' is ready for writing, and apply resume
     (obtained from a call to a-sync) to the return value of 'proc'.
     'proc' should take two arguments, the first of which will be set by
     glib to the g-io-channel object constructed for the watch and the
     second of which will be set to the GIOCondition ('out or 'err)
     provided by glib which caused the watch to activate.  It is
     intended to be called in a waitable procedure invoked by a-sync.
     The watch is multi-shot - it is for the user to bring it to an end
     at the right time by calling g-source-remove in the waitable
     procedure on the id tag returned by this procedure.  Any port for
     the file descriptor 'fd' is not referenced for garbage collection
     purposes - it must remain valid while the read watch is active.
     This procedure is mainly intended as something from which
     higher-level asynchronous file operations can be constructed.

     The documentation on the a-sync-glib-read-watch procedure comments
     about about the difficulties of using GIOChannel file watches with
     buffered ports.  The difficulties are not quite so intense with
     write watches, but users are likely to get best results by using
     unbuffered output ports (say by using the open-file or fdopen
     procedure with the '0' mode option or the R6RS
     open-file-output-port procedure with a buffer-mode of none, or by
     calling setvbuf).

     Because this procedure takes a 'resume' argument derived from the
     a-sync procedure, it must (like the a-sync procedure) in practice
     be called in the same thread as that in which the default glib main
     loop runs.

     This procedure should not throw an exception unless memory is
     exhausted, or guile-glib throws for some other reason.  If 'proc'
     throws, say because of port errors, and the exception is not caught
     locally, it will propagate out of g-main-loop-run.

     As an example of how to use a-sync-glib-write-watch, here is the
     implementation of await-glib-put-string:
          (define (await-glib-put-string await resume port text)
            (define length (string-length text))
            (define index 0)
            (define bv
              (let ((encoding (or (port-encoding port)
          			(fluid-ref %default-port-encoding)
          			"ISO-8859-1"))
          	  (conversion-strategy (port-conversion-strategy port)))
                (iconv:string->bytevector text encoding conversion-strategy)))
            (define id (a-sync-glib-write-watch resume
          				      (port->fdes port)
          				      (lambda (ioc status)
          					(catch 'system-error
          					  (lambda ()
          					    (let next ()
          					      (if (= index length)
          						  #f
          						  (begin
          						    (put-u8 port (bytevector-u8-ref bv index))
          						    (set! index (1+ index))
          						    (next)))))
          					  (lambda args
          					    (if (or (= EAGAIN (system-error-errno args))
          						    (and (defined? 'EWOULDBLOCK)
          							 (= EWOULDBLOCK (system-error-errno args))))
          						'more
          						(apply throw args)))))))
            (let next ((res (await)))
              (if (eq? res 'more)
          	(next (await))
          	(begin
          	  (g-source-remove id)
          	  (release-port-handle port)))))

 -- Scheme Procedure: await-glib-put-string await resume port text
     This is a convenience procedure which will start a write watch on
     'port' for writing a string to the port.  It calls 'await' while
     waiting for output to become available.  Provided 'port' is a
     non-blocking port, the event loop will not be blocked by this
     procedure even if only individual characters can be written at any
     one time.  It is intended to be called in a waitable procedure
     invoked by a-sync, and this procedure is implemented using
     a-sync-glib-write-watch.

     'port' must be a non-blocking port, or this procedure may block the
     event loop when writing.  In addition, it should be unbuffered (say
     by using the open-file, fdopen or duplicate-port procedure with the
     '0' mode option, or by calling setvbuf), or any buffer flushing
     operation may also block.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the first call to 'await' is made),
     which shouldn't happen unless memory is exhausted or a conversion
     error is encountered.  Subsequent exceptions (say, because of port
     errors) will propagate out of event-loop-run!.

     The bytes to be sent will be converted from the passed in string
     representation using the encoding of 'port' if a port encoding has
     been set, or otherwise using the program's default port encoding,
     or if neither has been set using iso-8859-1 (Latin-1).  Exceptions
     from conversion errors will propagate out of this procedure when
     setting up if conversion fails and a conversion strategy of 'error
     is in effect.  This procedure uses the conversion strategy for
     'port' (which defaults at program start-up to 'substitute).

     If CR-LF line endings are to be written when outputting the string,
     the '\r' character (as well as the '\n' character) must be embedded
     in the string.

     This procedure is first available in version 0.10 of this library.


File: guile-a-sync.info,  Node: compose,  Prev: gnome glib,  Up: Top

This (a-sync compose) module provides a compose-a-sync macro interface
for the a-sync procedure provided by the *note (a-sync coroutines):
coroutines. module.

 -- Syntax: (compose-a-sync [loop] ((var await-exp0) ...) await-exp1
          await-exp2 ...)
     This module provides the compose-a-sync macro.  This does two
     things: first, it calls a-sync for you and deals with the resulting
     'await' and 'resume' procedures without exposing them, which for
     many simple uses makes a-sync easier to use; and secondly it
     enables asynchronous tasks to be more easily composed on an event
     loop with intermediate results, by using a let* type syntax (in
     fact, let* is used internally).

     The 'loop' argument of compose-a-sync is optional.  If an event
     loop constructed by make-event-loop is passed to 'loop', then that
     is the main loop on which the tasks will be composed, otherwise if
     there is no 'loop' argument given, the default main loop will be
     used.  This is followed by bindings which are optional (there need
     not be any), each of which must be initialised by an expression
     comprising the application of a 'compose-a-sync'-capable procedure,
     and following the bindings there must be a body of
     'compose-a-sync'-capable procedures executed solely for the purpose
     of asynchronous side effects (this macro does not, and cannot,
     return a value because as soon as the first await is made control
     is passed to the event loop).  As in the case of let*, unlike the
     bindings the body cannot be empty - there must be at least one
     expression comprising the application of a 'compose-a-sync'-capable
     procedure in the body.

     As in the case of let*, each 'compose-a-sync'-capable procedure
     initializing a binding can see the values of the initializations
     made prior to it.  Unlike let*, compose-a-sync blocks cannot be
     nested within other compose-a-sync blocks.  Furthermore, within a
     compose-a-sync block, the result obtained from a
     'compose-a-sync'-capable procedure cannot be passed directly as an
     argument to another 'compose-a-sync'-capable procedure: the
     intermediate result must be stored as the value of a binding in the
     compose-a-sync block.

     A 'compose-a-sync'-capable procedure is one which takes an 'await'
     and 'yield' procedure from a-sync as its first and second
     arguments, and (if the optional 'loop' argument of this macro is
     used) takes the event loop as its third argument, followed by such
     further arguments as it requires.  All of the await-task!,
     await-task-in-thread!, await-task-in-event-loop!, await-generator!,
     await-generator-in-thread!, await-generator-in-event-loop!,
     await-timeout!, await-getline!, await-geteveryline!,
     await-getsomelines!  and await-put-string!  procedures provided by
     the *note (a-sync event-loop): event loop. module are
     'compose-a-sync'-capable.  In addition, to make an ordinary body of
     code which does not block (and which does not need to invoke
     a-sync's await procedure) usable by compose-a-sync, the no-await
     macro can be used to generate a 'compose-a-sync'-capable procedure
     for it (see below).

     Each binding is initialized as if sequentially (although it is done
     asynchronously on the relevant event loop).  An initialization does
     not begin until an earlier one has completed.  In addition, each
     clause in the body is executed sequentially in turn, but does so
     asynchronously on the event loop using 'await' semantics.

     When calling a 'compose-a-sync'-capable procedure within a
     'compose-a-sync' block (including when initializing its bindings),
     the 'await' and 'yield' and event-loop arguments are not explicitly
     passed to it.  The compose-a-sync macro will do it for you.

          (set-default-event-loop!) ;; if none has yet been set
          (compose-a-sync ((line (await-getline! (open "/dev/tty" O_RDONLY))))
          	      ((no-await (simple-format #t
          					"The line was: ~A\n"
          					line))))
          (event-loop-run!)

     The await-glib-task, await-glib-task-in-thread,
     await-glib-generator, await-glib-generator-in-thread,
     await-glib-timeout, await-glib-getline and await-glib-put-string
     procedures in the *note (a-sync gnome-glib): gnome glib. module
     also meet the 'compose-a-sync'-capable requirements.  Here is the
     same example using those procedures:

          (define main-loop (g-main-loop-new #f #f))
          (compose-a-sync ((line (await-glib-getline (open-file-input-port "/dev/tty" (file-options) (buffer-mode none)))))
          	      ((no-await (simple-format #t
          					"The line was: ~A\n"
          					line)
          			 (g-main-loop-quit main-loop))))
          (g-main-loop-run main-loop)

     Each block of code within a compose-a-sync block will run
     independently of (and concurrently with) code in other
     compose-a-sync blocks.  Asynchronous operations are only serialized
     within any one compose-a-sync block.  As soon as any code calls
     a-sync's 'await' procedure in a compose-a-sync block,
     compose-a-sync will return and begin executing whatever follows it,
     and further execution of the compose-a-sync block will occur within
     the event loop concerned.

     Other examples of the use of this macro are given in the
     documentation of the *note (a-sync coroutines): coroutines. module.

     This macro must (like the a-sync procedure) be called in the same
     thread as that in which the event loop runs.

 -- Syntax: (no-await body0 body1 ...)
     This macro will generate a 'compose-a-sync'-capable procedure from
     a body of code which does not block.  It can be passed to
     compose-a-sync, either for use as an initializer or as a clause in
     its body.  When used as an initializer, it evaluates to the value
     of the last expression in the 'no-await' body.

     If the body throws an exception which is not caught locally, it
     will propagate out of event-loop-run!  or g-main-loop-run, as the
     case may be.

     Here is an example of the use of no-await:

          (var ((no-await (+ a b))))



Tag Table:
Node: Top85
Node: overview1123
Node: coroutines4061
Node: event loop22012
Node: monotonic time81431
Node: gnome glib82865
Node: compose110683

End Tag Table
