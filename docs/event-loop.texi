
@node event loop,monotonic time,coroutines,Top

The (a-sync event-loop) module provides the follow procedures:

@deffn {Scheme Procedure} make-event-loop
This constructs a new event loop object.
@end deffn

@deffn {Scheme Procedure} event-loop? obj
This procedure indicates whether 'obj' is an event-loop object
constructed by make-event-loop.
@end deffn

@deffn {Scheme Procedure} event-loop-run! loop
This starts the event loop, which runs in the thread which calls this
procedure.  Where event-loop-quit! has been called, this procedure may
be called again to restart the same event loop.  If a callback throws,
or something else throws in the implementation, then this procedure
will return and it will be as if event-loop-quit! had been called.
@end deffn

@deffn {Scheme Procedure} event-loop-add-read-watch! loop file proc
The 'proc' callback should take a single argument, and when called
this will be set to 'in or 'excpt.  The same port or file descriptor
can also be passed to event-loop-add-write-watch, and if so and the
descriptor is also available for writing, the write callback will also
be called with its argument set to 'out.  If there is already a read
watch for the file passed, the old one will be replaced by the new
one.  If proc returns #f, the read watch (and any write watch for the
same file) will be removed from the event loop, otherwise the watch
will continue.  This is thread safe - any thread may add a watch, and
the callback will execute in the event loop thread.  The file argument
can be either a port or a file descriptor.  If 'file' is a file
descriptor, any port for the descriptor is not referenced for garbage
collection purposes - it must remain valid while operations are
carried out on the descriptor.  If 'file' is a buffered port,
buffering will be taken into account in indicating whether a read can
be made without blocking (but on a buffered port, for efficiency
purposes each read operation in response to this watch should usually
exhaust the buffer by looping on char-ready?).
@end deffn

@deffn {Scheme Procedure} event-loop-add-write-watch! loop file proc
The 'proc' callback should take a single argument, and when called
this will be set to 'out or 'excpt.  The same port or file descriptor
can also be passed to event-loop-add-read-watch, and if so and the
descriptor is also available for reading or in error, the read
callback will also be called with its argument set to 'in or 'excpt
(if both a read and a write watch have been set for the same file
argument, and there is an exceptional condition, it is the read watch
procedure which will be called with 'excpt rather than the write watch
procedure).  If there is already a write watch for the file passed,
the old one will be replaced by the new one.  If proc returns #f, the
write watch (and any read watch for the same file) will be removed
from the event loop, otherwise the watch will continue.  This is
thread safe - any thread may add a watch, and the callback will
execute in the event loop thread.  The file argument can be either a
port or a file descriptor.  If 'file' is a file descriptor, any port
for the descriptor is not referenced for garbage collection purposes -
it must remain valid while operations are carried out on the
descriptor.  If 'file' is a buffered port, buffering will be taken
into account in indicating whether a write can be made without
blocking.
@end deffn

@deffn {Scheme Procedure} event-loop-remove-watch! loop file
The file argument may be a port or a file descriptor, and this removes
any read and write watch previously entered for that port or file
descriptor.  This is thread safe - any thread may remove a watch.  A
file descriptor and a port with the same underlying file descriptor
compare equal for the purposes of removal.
@end deffn

@deffn {Scheme Procedure} event-post! loop action
The 'action' callback is a thunk.  This is thread safe - any thread
may post an event (that is its main purpose), and the action callback
will execute in the event loop thread.  Actions execute in the order
in which they were posted.  If an event is posted from a worker
thread, it will normally be necessary to call event-loop-block!
beforehand.
@end deffn

@deffn {Scheme Procedure} timeout-post! loop msecs action
This adds a timeout to the event loop.  The timeout will repeat unless
and until the passed-in callback returns #f or timeout-remove! is
called.  The passed-in callback must be a thunk.  This procedure
returns a tag symbol to which timeout-remove! can be applied.  It may
be called by any thread.
@end deffn


@deffn {Scheme Procedure} timeout-remove! loop tag
This stops the timeout with the given tag from executing in the event
loop concerned.  It may be called by any thread.
@end deffn

@deffn {Scheme Procedure} event-loop-block! loop val
By default, upon there being no more watches, timeouts and posted
events for an event loop, event-loop-run! will return, which is
normally what you want with a single threaded program.  However, this
is undesirable where a worker thread is intended to post an event to
the main loop after it has reached a result, say via
await-task-in-thread, because the main loop may have ended before it
posts.  Passing #t to the val argument of this procedure will prevent
that from happening, so that the event loop can only be ended by
calling event-loop-quit!.  To switch it back to non-blocking mode,
pass #f.  This is thread safe - any thread may call this procedure.
@end deffn

@deffn {Scheme Procedure} event-loop-quit! loop
Causes the event loop to unblock.  Any events remaining in the event
loop will be discarded.  New events may subsequently be added after
event-loop-run! has unblocked and event-loop-run! then called for
them.  This is thread safe - any thread may call this procedure.
@end deffn

@deffn {Scheme Procedure} await-task-in-thread! loop await resume thunk [handler]
This is a convenience procedure which will run 'thunk' in its own
thread, and then post an event to the event loop specified by the
'loop' argument when 'thunk' has finished.  This procedure calls
'await' and will return the thunk's return value.  It is intended to
be called in a waitable procedure invoked by a-sync.  It will normally
be necessary to call event-loop-block! before invoking this procedure.
If the optional 'handler' argument is provided, then it will be run in
the event loop thread if 'thunk' throws and its return value will be
the return value of this procedure; otherwise the program will
terminate if an unhandled exception propagates out of 'thunk'.
'handler' should take the same arguments as a guile catch handler
(this is implemented using catch).  If 'handler' throws, the exception
will propagate out of event-loop-run!.

Here is an example:
@example
(define main-loop (make-event-loop))
(a-sync (lambda (await resume)
	  (simple-format #t "1 + 1 is ~A\n"
			 (await-task-in-thread! main-loop
						await resume
						(lambda ()
						  (+ 1 1))))))
(event-loop-run! main-loop)
@end example
@end deffn

@deffn {Scheme Procedure} await-task! loop await resume thunk
This is a convenience procedure for use with an event loop, which will
run 'thunk' in the event loop specified by the 'loop' argument, and
then post an event to the event loop specified by the 'loop' argument
when 'thunk' has finished.  This procedure calls 'await' and will
return the thunk's return value.  It is intended to be called in a
waitable procedure invoked by a-sync.  It is the single-threaded
corollary of await-task-in-thread!.  This means that (unlike with
await-task-in-thread!) while the task is running other events in the
event loop will not make progress.  This is not particularly useful
except when called by the event loop thread for the purpose of
bringing the event loop to an end at its own place in the event queue,
or when called by a worker thread to report a result expected by a
waitable procedure running in the event loop thread.  (For the latter
case though, await-task-in-thread! is generally a more convenient
wrapper.)

Here is an example:
@example
(define main-loop (make-event-loop))
(a-sync (lambda (await resume)
	  (simple-format #t "1 + 1 is ~A\n"
			 (await-task! main-loop
				      await resume
				      (lambda ()
					(+ 1 1))))))
(event-loop-run! main-loop)
@end example
@end deffn

@deffn {Scheme Procedure} await-timeout! loop msec await resume thunk
This is a convenience procedure for use with an event loop, which will
run 'thunk' in the event loop thread when the timeout expires.  This
procedure calls 'await' and will return the thunk's return value.  It
is intended to be called in a waitable procedure invoked by a-sync.
The timeout is single shot only - as soon as 'thunk' has run once and
completed, the timeout will be removed from the event loop.

Here is an example:
@example
(define main-loop (make-event-loop))
(a-sync (lambda (await resume)
	  (simple-format #t
			 "Timeout ~A\n"
			 (await-timeout! main-loop 100
					 await resume
					 (lambda ()
					   "expired")))))
(event-loop-run! main-loop)
@end example
@end deffn

@deffn {Scheme Procedure} a-sync-read-watch! loop file resume proc
This is a convenience procedure for use with an event loop, which will
run 'proc' in the event loop thread whenever 'file' is ready for
reading, and apply resume (obtained from a call to a-sync) to the
return value of 'proc'.  'file' can be a port or a file descriptor
(and if it is a file descriptor, the revealed count is not
incremented).  'proc' should take a single argument which will be set
by the event loop to 'in or 'excpt (see the documentation on
event-loop-add-read-watch! for further details).  It is intended to be
called in a waitable procedure invoked by a-sync.  The watch is
multi-shot - it is for the user to bring it to an end at the right
time by calling event-loop-remove-watch! in the waitable procedure.
This procedure is mainly intended as something from which higher-level
asynchronous file operations can be constructed, such as the
await-readline! procedure.

As an example of how to use a-sync-read-watch!, here is the
implementation of await-getline!:
@example
(define (await-getline! loop port await resume)
  (define text '())
  (a-sync-read-watch! loop
		      port
		      resume
		      (lambda (status)
			(read-char port)))
  (let next ([ch (await)])
    (if (not (char=? ch #\newline))
	(begin
	  (set! text (cons ch text))
	  (next (await)))
	(begin
	  (event-loop-remove-watch! loop port)
	  (reverse-list->string text)))))
@end example
@end deffn

@deffn {Scheme Procedure} await-getline! loop port await resume
This is a convenience procedure for use with an event loop, which will
start a read watch on 'port' for a line of input.  It calls 'await'
while waiting for input and will return the line of text received
(without the terminating '\n' character).  The event loop will not be
blocked by this procedure even if only individual characters are
available at any one time.  It is intended to be called in a waitable
procedure invoked by a-sync.  This procedure is implemented using
a-sync-read-watch!.

Here is an example:
@example
(define main-loop (make-event-loop))
(a-sync (lambda (await resume)
	  (display "Enter a line of text at the keyboard\n")
	  (simple-format #t
			 "The line was: ~A\n"
			 (await-getline! main-loop
					  (open "/dev/tty" O_RDONLY)
					  await resume))))
(event-loop-run! main-loop)
@end example
@end deffn

@deffn {Scheme Procedure} a-sync-write-watch! loop file resume proc
This is a convenience procedure for use with an event loop, which will
run 'proc' in the event loop thread whenever 'file' is ready for
writing, and apply resume (obtained from a call to a-sync) to the
return value of 'proc'.  'file' can be a port or a file descriptor
(and if it is a file descriptor, the revealed count is not
incremented).  'proc' should take a single argument which will be set
by the event loop to 'out or 'excpt (see the documentation on
event-loop-add-write-watch! for further details).  It is intended to
be called in a waitable procedure invoked by a-sync.  The watch is
multi-shot - it is for the user to bring it to an end at the right
time by calling event-loop-remove-watch! in the waitable procedure.
This procedure is mainly intended as something from which higher-level
asynchronous file operations can be constructed.
@end deffn

The (async event-loop) module also loads the @ref{monotonic
time,,(a-sync monotonic-time)} module.
