@node event loop,monotonic time,coroutines,Top

The (a-sync event-loop) module provides an event loop for asynchronous
operations.  The event loop does not of itself start any new threads.
Instead it runs in the thread which calls event-loop-run!: that
procedure will block while there are events to be processed.  In most
programs the event loop will run in the main program thread, with
which the program began.  Many programs using event loops are entirely
single threaded.

However, the event loop provided by this module does support multiple
threads.  Most of the event loop procedures in this module are thread
safe and may be called in any thread.  The thread safe procedures are
event-loop-run! (as mentioned, this will cause the event loop to run
in the thread which calls it), event-loop-block!, event-loop-quit!,
event-post!, event-loop-tasks, event-loop-add-read-watch!,
event-loop-add-write-watch!, event-loop-remove-read-watch!,
event-loop-remove-write-watch!, timeout-post! and timeout-remove!.  In
particular, event-post! allows worker threads to post an event to an
event loop, say with the result of a computation, so that the event
callback will execute in the event loop thread.

The file watches provided by this module use guile's wrapper for the
select() system call.  This has two consequences.  First, in linux
select() applied to sockets can give rise to spurious wake-ups, which
means that it may be best with sockets to set the socket as
non-blocking using the guile wrapper for the fcntl() system call in
order to prevent a blocking read where it is not expected
(EAGAIN/EWOULDBLOCK is handled correctly by the await-getline!,
await-geteveryline! and await-getsomelines! procedures from version
0.5, and by await-put-string!).  Secondly, with select() the file
descriptor value of a port passed to the watch should not exceed
FD_SETSIZE.  Normally, by default the maximum soft user limit for open
files is the same as FD_SETSIZE, and it is best if this situation is
retained by user code.

Where a file watch on a file descriptor or port has been added with
event-loop-add-read-watch! or event-loop-add-write-watch!, the event
loop should be treated as owning the status of the descriptor or port
until it has subsequently been removed with
event-loop-remove-read-watch! or event-loop-remove-write-watch!.  In
particular, if the watch is on a port, an error in the fileno
procedure will arise at some point if the port is closed (say by
calling close, close-port, close-input-port or close-output-port)
before its watch has been removed from the event loop; if the watch is
on a file descriptor and the descriptor value is reused by the
operating system, there may be a phantom watch on the new descriptor.
Also note that if a worker thread other than the event loop thread
removes the watch and immediately follows it with a close of the port
or descriptor, the file watch callback may be called once in
consequence, so in such a case either the callback should be ready to
handle a possibly closed port or descriptor or the worker thread
should post the closing as an event using event-post!.

This modules provides the following procedures:

@deffn {Scheme Procedure} set-default-event-loop! [loop]
The 'loop' (event loop) argument is optional.  This procedure sets the
default event loop for the procedures in this module to the one passed
in (which must have been constructed by the make-event-loop
procedure), or if no argument is passed (or #f is passed), a new event
loop will be constructed for you as the default, which can be accessed
via the get-default-event-loop procedure.  The default loop variable
is not a fluid or a parameter - it is intended that the default event
loop is the same for every thread in the program, and that the default
event loop would normally run in the thread with which the program
started.  This procedure is not thread safe - if it might be called by
a different thread from others which might access the default event
loop, then external synchronization may be required.  However, that
should not normally be an issue.  The normal course would be to call
this procedure once only on program start up, before other threads
have started.  It is usually a mistake to call this procedure twice:
if there are asynchronous events pending (that is, if event-loop-run!
has not returned) you will probably not get the results you expect.

Note that if a default event-loop is constructed for you because no
argument is passed (or #f is passed), no throttling arguments are
applied to it (see the documentation on make-event-loop for more about
that).  If throttling is wanted, the make-event-loop procedure should
be called explicitly and the result passed to this procedure.
@end deffn

@deffn {Scheme Procedure} get-default-event-loop
This returns the default loop set by the set-default-event-loop!
procedure, or #f if none has been set.
@end deffn

@deffn {Scheme Procedure} make-event-loop [throttle-threshold throttle-delay]
This constructs a new event loop object.  From version 0.8, this
procedure optionally takes two throttling arguments for backpressure
when applying the event-post! procedure to the event loop.  The
'throttle-threshold' argument specifies the number of unexecuted tasks
queued for execution, by virtue of calls to event-post!, at which
throttling will first be applied.  Where the threshold is exceeded,
throttling proceeds by adding a wait to any thread which calls the
event-post! procedure, equal to the cube of the number of times (if
any) by which the number of queued tasks exceeds the threshold
multiplied by the value of 'threshold-delay'.  The value of
'threshold-delay' should be given in microseconds.  Throttling is only
applied where the call to event-post! is made in a thread other than
the one in which the event loop runs.

So if the threshold given is 10000 tasks and the delay given is 1000
microseconds, upon 10000 unexecuted tasks accumulating a delay of 1000
microseconds will be applied to callers of event-post! which are not
in the event loop thread, at 20000 unexecuted tasks a delay of 8000
microseconds will be applied, and at 30000 unexecuted tasks a delay of
27000 microseconds will be applied, and so on.

If throttle-threshold and throttle-delay arguments are not provided
(or #f is passed for them), then no throttling takes place.
@end deffn

@deffn {Scheme Procedure} event-loop? obj
This procedure indicates whether 'obj' is an event-loop object
constructed by make-event-loop.
@end deffn

@deffn {Scheme Procedure} event-loop-run! [loop]
The 'loop' (event loop) argument is optional.  This procedure starts
the event loop passed in as an argument, or if none is passed (or #f
is passed) it starts the default event loop.  The event loop will run
in the thread which calls this procedure.  If this procedure has
returned, including after a call to event-loop-quit!, this procedure
may be called again to restart the event loop.  If a callback throws,
or something else throws in the implementation, then this procedure
will clean up the event loop as if event-loop-quit! had been called,
and the exception will be rethrown out of this procedure.
@end deffn

@deffn {Scheme Procedure} event-loop-add-read-watch! file proc [loop]
The 'loop' (event loop) argument is optional.  This procedure will
start a read watch in the event loop passed in as an argument, or if
none is passed (or #f is passed), in the default event loop.  The
'proc' callback should take a single argument, and when called this
will be set to 'in or 'excpt.  The same port or file descriptor can
also be passed to event-loop-add-write-watch, and if so and the
descriptor is also available for writing, the write callback will also
be called with its argument set to 'out.  If there is already a read
watch for the file passed, the old one will be replaced by the new
one.  If 'proc' returns #f, the read watch will be removed from the
event loop, otherwise the watch will continue.  This is thread safe -
any thread may add a watch, and the callback will execute in the event
loop thread.  The file argument can be either a port or a file
descriptor.  If 'file' is a file descriptor, any port for the
descriptor is not referenced for garbage collection purposes - it must
remain valid while operations are carried out on the descriptor.  If
'file' is a buffered port, buffering will be taken into account in
indicating whether a read can be made without blocking (but on a
buffered port, for efficiency purposes each read operation in response
to this watch should usually exhaust the buffer by calling drain-input
or by looping on char-ready?).

This procedure should not throw an exception unless memory is
exhausted.
@end deffn

@deffn {Scheme Procedure} event-loop-add-write-watch! file proc [loop]
The 'loop' (event loop) argument is optional.  This procedure will
start a write watch in the event loop passed in as an argument, or if
none is passed (or #f is passed), in the default event loop.  The
'proc' callback should take a single argument, and when called this
will be set to 'out or 'excpt.  The same port or file descriptor can
also be passed to event-loop-add-read-watch, and if so and the
descriptor is also available for reading or in exceptional condition,
the read callback will also be called with its argument set to 'in or
'excpt (if both a read and a write watch have been set for the same
file argument, and there is an exceptional condition, it is the read
watch procedure which will be called with 'excpt rather than the write
watch procedure, so if that procedure returns #f only the read watch
will be removed).  If there is already a write watch for the file
passed, the old one will be replaced by the new one.  If 'proc'
returns #f, the write watch will be removed from the event loop,
otherwise the watch will continue.  This is thread safe - any thread
may add a watch, and the callback will execute in the event loop
thread.  The file argument can be either a port or a file descriptor.
If 'file' is a file descriptor, any port for the descriptor is not
referenced for garbage collection purposes - it must remain valid
while operations are carried out on the descriptor.

If 'file' is a buffered port, buffering will be taken into account in
indicating whether a write can be made without blocking, either
because there is room in the buffer for a character, or because the
underlying file descriptor is ready for a character.  This can have
unintended consequences: if the buffer is full but the underlying file
descriptor is ready for a character, the next write will cause a
buffer flush, and if the size of the buffer is greater than the number
of characters that the file can receive without blocking, blocking
might still occur.  Unless the port will carry out a partial flush in
such a case, this procedure will therefore generally work best with
unbuffered ports (say by using the open-file, fdopen or duplicate-port
procedure with the '0' mode option or the R6RS open-file-input-port
procedure with a buffer-mode of none, or by calling setvbuf).

This procedure should not throw an exception unless memory is
exhausted.
@end deffn

@deffn {Scheme Procedure} event-loop-remove-read-watch! file [loop]
The 'loop' (event loop) argument is optional.  This procedure will
remove a read watch from the event loop passed in as an argument, or
if none is passed (or #f is passed), from the default event loop.  The
file argument may be a port or a file descriptor.  This is thread safe
- any thread may remove a watch.  A file descriptor and a port with
the same underlying file descriptor compare equal for the purposes of
removal.
@end deffn

@deffn {Scheme Procedure} event-loop-remove-write-watch! file [loop]
The 'loop' (event loop) argument is optional.  This procedure will
remove a write watch from the event loop passed in as an argument, or
if none is passed (or #f is passed), from the default event loop.  The
file argument may be a port or a file descriptor.  This is thread safe
- any thread may remove a watch.  A file descriptor and a port with
the same underlying file descriptor compare equal for the purposes of
removal.
@end deffn

@deffn {Scheme Procedure} event-post! action [loop]
The 'loop' (event loop) argument is optional.  This procedure will
post a callback for execution in the event loop passed in as an
argument, or if none is passed (or #f is passed), in the default event
loop.  The 'action' callback is a thunk.  This is thread safe - any
thread may post an event (that is its main purpose), and the action
callback will execute in the event loop thread.  Actions execute in
the order in which they were posted.  If an event is posted from a
worker thread, it will normally be necessary to call event-loop-block!
beforehand.

This procedure should not throw an exception unless memory is
exhausted.  If the 'action' callback throws, and the exception is not
caught locally, it will propagate out of event-loop-run!.

Where this procedure is called by other than the event loop thread,
throttling may take place if the number of posted callbacks waiting to
execute exceeds the threshold set for the event loop - see the
documentation on make-event-loop for further details.
@end deffn

@deffn {Scheme Procedure} timeout-post! msecs action [loop]
The 'loop' (event loop) argument is optional.  This procedure adds a
timeout to the event loop passed in as an argument, or if none is
passed (or #f is passed), to the default event loop.  The timeout will
repeat unless and until the passed-in callback returns #f or
timeout-remove! is called.  The passed-in callback must be a thunk.
This procedure returns a tag symbol to which timeout-remove! can be
applied.  It may be called by any thread, and the timeout callback
will execute in the event loop thread.

This procedure should not throw an exception unless memory is
exhausted.  If the 'action' callback throws, and the exception is not
caught locally, it will propagate out of event-loop-run!.
@end deffn

@deffn {Scheme Procedure} timeout-remove! tag [loop]
The 'loop' (event loop) argument is optional.  This procedure stops
the timeout with the given tag from executing in the event loop passed
in as an argument, or if none is passed (or #f is passed), in the
default event loop.  It may be called by any thread.
@end deffn

@deffn {Scheme Procedure} event-loop-tasks [loop]
This procedure returns the number of callbacks posted to an event loop
with the event-post! procedure which at the time still remain queued
for execution.  Amongst other things, it can be used by a calling
thread which is not the event loop thread to determine whether
throttling is likely to be applied to it when calling event-post! -
see the documentation on make-event-loop for further details.

The 'loop' (event loop) argument is optional: this procedure operates
on the event loop passed in as an argument, or if none is passed (or
#f is passed), on the default event loop.  This procedure is thread
safe - any thread may call it.

This procedure is first available in version 0.8 of this library.
@end deffn

@deffn {Scheme Procedure} event-loop-block! val [loop]
By default, upon there being no more watches, timeouts and posted
events for an event loop, event-loop-run! will return, which is
normally what you want with a single threaded program.  However, this
is undesirable where a worker thread is intended to post an event to
the main loop after it has reached a result, say via
await-task-in-thread!, because the main loop may have ended before it
posts.  Passing #t to the val argument of this procedure will prevent
that from happening, so that the event loop can only be ended by
calling event-loop-quit!, or by calling event-loop-block! again with a
#f argument (to switch the event loop back to non-blocking mode, pass
#f).  This is thread safe - any thread may call this procedure.  The
'loop' (event loop) argument is optional: this procedure operates on
the event loop passed in as an argument, or if none is passed (or #f
is passed), on the default event loop.
@end deffn

@deffn {Scheme Procedure} event-loop-quit! [loop]
This procedure causes an event loop to unblock.  Any events remaining
in the event loop will be discarded.  New events may subsequently be
added after event-loop-run! has unblocked and event-loop-run! then
called for them.  This is thread safe - any thread may call this
procedure.  The 'loop' (event loop) argument is optional: this
procedure operates on the event loop passed in as an argument, or if
none is passed (or #f is passed), on the default event loop.
@end deffn

@deffn {Scheme Procedure} await-task-in-thread! await resume [loop] thunk [handler]
The loop and handler arguments are optional.  The procedure will run
'thunk' in its own thread, and then post an event to the event loop
specified by the 'loop' argument when 'thunk' has finished, or to the
default event loop if no 'loop' argument is provided or if #f is
provided as the 'loop' argument (pattern matching is used to detect
the type of the third argument).  This procedure calls 'await' and
will return the thunk's return value.  It is intended to be called in
a waitable procedure invoked by a-sync.  It will normally be necessary
to call event-loop-block! before invoking this procedure.  If the
optional 'handler' argument is provided, then that handler will be run
in the event loop thread if 'thunk' throws and the return value of the
handler would become the return value of this procedure; otherwise the
program will terminate if an unhandled exception propagates out of
'thunk'.  'handler' should take the same arguments as a guile catch
handler (this is implemented using catch).

This procedure must (like the a-sync procedure) be called in the same
thread as that in which the event loop runs, where the result of
calling 'thunk' will be received.  As mentioned above, the thunk
itself will run in its own thread.

As the worker thread calls event-post!, it might be subject to
throttling by the event loop concerned.  See the documentation on the
make-event-loop procedure for further information about that.

Exceptions may propagate out of this procedure if they arise while
setting up (that is, before the worker thread starts), which shouldn't
happen unless memory is exhausted or pthread has run out of resources.
Exceptions arising during execution of the task, if not caught by a
handler procedure, will terminate the program.  Exceptions thrown by
the handler procedure will propagate out of event-loop-run!.

Here is an example of the use of await-task-in-thread!:
@example
(set-default-event-loop!) ;; if none has yet been set
(a-sync (lambda (await resume)
	  (simple-format #t "1 + 1 is ~A\n"
			 (await-task-in-thread! await resume
						(lambda ()
						  (+ 1 1))))
	  (event-loop-quit!)))
(event-loop-block! #t) ;; because the task runs in another thread
(event-loop-run!)
@end example
@end deffn

@deffn {Scheme Procedure} await-task-in-event-loop! await resume [waiter] worker thunk
The 'waiter' argument is optional.  The 'worker' argument is an event
loop running in a different thread than the one in which this
procedure is called, and is the one in which 'thunk' will be executed
by posting an event to that loop.  The result of executing 'thunk'
will then be posted to the event loop specified by the 'waiter'
argument, or to the default event loop if no 'waiter' argument is
provided or if #f is provided as the 'waiter' argument, and will
comprise this procedure's return value.  This procedure is intended to
be called in a waitable procedure invoked by a-sync.  It will normally
be necessary to call event-loop-block! on 'waiter' (or on the default
event loop) before invoking this procedure.

This procedure calls 'await' and must (like the a-sync procedure) be
called in the same thread as that in which the 'waiter' or default
event loop runs (as the case may be).

This procedure acts as a form of channel through which two different
event loops may communicate.  It also offers a means by which a master
event loop (the waiter or default event loop) may allocate work to
worker event loops for execution.  It would be nice to have a pool of
worker event loops for the purpose, but that is a work for the future.

Depending on the circumstances, it may be desirable to provide
throttling arguments when constructing the 'worker' event loop, in
order to enable backpressure to be supplied if the 'worker' event loop
becomes overloaded: see the documentation on the make-event-loop
procedure for further information about that.  (This procedure calls
event-post! in both the 'waiter' and 'worker' event loops by the
respective threads of the other, so either could be subject to
throttling.)

Exceptions may propagate out of this procedure if they arise while
setting up, which shouldn't happen unless memory is exhausted or
pthread has run out of resources.  Exceptions arising during execution
of the task, if not caught locally, will propagate out of the
event-loop-run! procedure called for the 'worker' event loop.

This procedure is first available in version 0.8 of this library.

Here is an example of the use of await-task-in-event-loop!:
@example
(set-default-event-loop!)     ;; if none has yet been set
(define worker (make-event-loop))
(event-loop-block! #t)        ;; because the task runs in another thread
(event-loop-block! #t worker)

(call-with-new-thread
 (lambda ()
   (event-loop-run! worker)))

(a-sync (lambda (await resume)
	  (let ((res
		 (await-task-in-event-loop! await resume worker
					    (lambda ()
					      (+ 5 10)))))
	    (simple-format #t "~A\n" res)
	    (event-loop-block! #f worker)
	    (event-loop-block! #f))))
(event-loop-run!)
@end example
@end deffn

@deffn {Scheme Procedure} await-task! await resume [loop] thunk
The 'loop' argument is optional.  This is a convenience procedure for
use with an event loop, which will run 'thunk' in the event loop
specified by the 'loop' argument, or in the default event loop if no
'loop' argument is provided or #f is provided as the 'loop' argument.
This procedure calls 'await' and will return the thunk's return value.
It is intended to be called in a waitable procedure invoked by a-sync.
It is the single-threaded corollary of await-task-in-thread!.  This
means that (unlike with await-task-in-thread!) while 'thunk' is
running other events in the event loop will not make progress, so
blocking calls should not be made in 'thunk'.  This procedure can be
useful for the purpose of implementing co-operative multi-tasking, say
by composing tasks with compose-a-sync (see the @ref{compose,,compose}
module).

This procedure must (like the a-sync procedure) be called in the same
thread as that in which the event loop runs.

This procedure calls event-post! in the event loop concerned.  This is
done in the same thread as that in which the event loop runs so it
cannot of itself be throttled.  However it may contribute to the
number of accumulated unexecuted tasks in the event loop and therefore
contribute to the throttling of other threads by the loop.  See the
documentation on the make-event-loop procedure for further information
about that.

Exceptions may propagate out of this procedure if they arise while
setting up (that is, before the task starts), which shouldn't happen
unless memory is exhausted.  Exceptions arising during execution of
the task, if not caught locally, will propagate out of
event-loop-run!.

Here is an example of the use of await-task!:
@example
(set-default-event-loop!) ;; if none has yet been set
(a-sync (lambda (await resume)
	  (simple-format #t "1 + 1 is ~A\n"
			 (await-task! await resume
				      (lambda ()
					(+ 1 1))))))
(event-loop-run!)
@end example
@end deffn

@deffn {Scheme Procedure} await-generator-in-thread! await resume [loop] generator proc [handler]
The 'loop' and 'handler' arguments are optional.  The 'generator'
argument is a procedure taking one argument, namely a yield argument
(see the documentation on the make-iterator procedure for further
details).  This await-generator-in-thread! procedure will run
'generator' in its own worker thread, and whenever 'generator' yields
a value will cause 'proc' to execute in the event loop specified by
the 'loop' argument (or in the default event loop if no 'loop'
argument is provided or if #f is provided as the 'loop' argument -
pattern matching is used to detect the type of the third argument).

'proc' should be a procedure taking a single argument, namely the
value yielded by the generator.  If the optional 'handler' argument is
provided, then that handler will be run in the event loop thread if
'generator' throws; otherwise the program will terminate if an
unhandled exception propagates out of 'generator'.  'handler' should
take the same arguments as a guile catch handler (this is implemented
using catch).

This procedure calls 'await' and will return when the generator has
finished or, if 'handler' is provided, upon the generator throwing an
exception.  This procedure will return #f if the generator completes
normally, or 'guile-a-sync-thread-error if the generator throws an
exception and 'handler' is run (the 'guile-a-sync-thread-error symbol
is reserved to the implementation and should not be yielded by the
generator).

This procedure is intended to be called in a waitable procedure
invoked by a-sync.  It will normally be necessary to call
event-loop-block! before invoking this procedure.

This procedure must (like the a-sync procedure) be called in the same
thread as that in which the event loop runs.  As mentioned above, the
generator itself will run in its own thread.

As the worker thread calls event-post!, it might be subject to
throttling by the event loop concerned.  See the documentation on the
make-event-loop procedure for further information about that.

Exceptions may propagate out of this procedure if they arise while
setting up (that is, before the worker thread starts), which shouldn't
happen unless memory is exhausted or pthread has run out of resources.
Exceptions arising during execution of the generator, if not caught by
a handler procedure, will terminate the program.  Exceptions thrown by
the handler procedure will propagate out of event-loop-run!.
Exceptions thrown by 'proc', if not caught locally, will also
propagate out of event-loop-run!.

This procedure is first available in version 0.9 of this library.

Here is an example of the use of await-generator-in-thread!:
@example
(set-default-event-loop!) ;; if none has yet been set
(a-sync (lambda (await resume)
          (await-generator-in-thread! await resume
				      (lambda (yield)
					(let loop ((count 0))
					  (when (< count 5)
					    (yield (* 2 count))
					    (loop (1+ count)))))
				      (lambda (val)
					(display val)
					(newline)))
	  (event-loop-block! #f)))
(event-loop-block! #t) ;; because the generator runs in another thread
(event-loop-run!)
@end example
@end deffn

@deffn {Scheme Procedure} await-generator-in-event-loop! await resume [waiter] worker generator proc
The 'waiter' argument is optional.  The 'worker' argument is an event
loop running in a different thread than the one in which this
procedure is called.  The 'generator' argument is a procedure taking
one argument, namely a yield argument (see the documentation on the
make-iterator procedure for further details).  This
await-generator-in-event-loop! procedure will cause 'generator' to run
in the 'worker' event loop, and whenever 'generator' yields a value
this will cause 'proc' to execute in the event loop specified by the
'waiter' argument, or in the default event loop if no 'waiter'
argument is provided or if #f is provided as the 'waiter' argument.
'proc' should be a procedure taking a single argument, namely the
value yielded by the generator.

This procedure is intended to be called in a waitable procedure
invoked by a-sync.  It will normally be necessary to call
event-loop-block! on 'waiter' (or on the default event loop) before
invoking this procedure.

This procedure calls 'await' and will return when the generator has
finished.  It must (like the a-sync procedure) be called in the same
thread as that in which the 'waiter' or default event loop runs (as
the case may be).

This procedure acts, with await-task-in-event-loop!, as a form of
channel through which two different event loops may communicate.  It
also offers a means by which a master event loop (the waiter or
default event loop) may allocate work to worker event loops for
execution.  It would be nice to have a pool of worker event loops for
the purpose, but that is a work for the future.

Depending on the circumstances, it may be desirable to provide
throttling arguments when constructing the 'worker' event loop, in
order to enable backpressure to be supplied if the 'worker' event loop
becomes overloaded: see the documentation on the make-event-loop
procedure for further information about that.
(This procedure calls event-post! in both the 'waiter' and 'worker'
event loops by the respective threads of the other, so either could
be subject to throttling.)

Exceptions may propagate out of this procedure if they arise while
setting up, which shouldn't happen unless memory is exhausted or
pthread has run out of resources.  Exceptions arising during execution
of the generator, if not caught locally, will propagate out of the
event-loop-run! procedure called for the 'worker' event loop.
Exceptions arising during the execution of 'proc', if not caught
locally, will propagate out of the event-loop-run! procedure called
for the 'waiter' or default event loop (as the case may be).

This procedure is first available in version 0.9 of this library.

Here is an example of the use of await-generator-in-event-loop!:
@example
(set-default-event-loop!)     ;; if none has yet been set
(define worker (make-event-loop))
(event-loop-block! #t)        ;; because the generator runs in another thread
(event-loop-block! #t worker)

(call-with-new-thread
 (lambda ()
   (event-loop-run! worker)))

(a-sync (lambda (await resume)
	  (await-generator-in-event-loop! await resume worker
					  (lambda (yield)
					    (let loop ((count 0))
					      (when (< count 5)
						(yield (* 2 count))
						(loop (1+ count)))))
					  (lambda (val)
					    (display val)
					    (newline)))
	  (event-loop-block! #f worker)
	  (event-loop-block! #f)))
(event-loop-run!)
@end example
@end deffn

@deffn {Scheme Procedure} await-generator! await resume [loop] generator proc
The 'loop' argument is optional.  The 'generator' argument is a
procedure taking one argument, namely a yield argument (see the
documentation on the make-iterator procedure for further details).
This await-generator! procedure will run 'generator', and whenever
'generator' yields a value will cause 'proc' to execute in the event
loop specified by the 'loop' argument, or in the default event loop if
no 'loop' argument is provided or #f is provided as the 'loop'
argument.  'proc' should be a procedure taking a single argument,
namely the value yielded by the generator.  Each time 'proc' runs it
will do so as a separate event in the event loop and so be
multi-plexed with other events.

This procedure must (like the a-sync procedure) be called in the same
thread as that in which the event loop runs.

This procedure is intended to be called in a waitable procedure
invoked by a-sync.  It is the single-threaded corollary of
await-generator-in-thread!.  This means that (unlike with
await-generator-in-thread!) while 'generator' is running other
events in the event loop will not make progress, so blocking calls
(other than to the yield procedure) should not be made in 'generator'.
This procedure can be useful for the purpose of implementing
co-operative multi-tasking, say by composing tasks with
compose-a-sync (see compose.scm).

This procedure calls event-post! in the event loop concerned.  This is
done in the same thread as that in which the event loop runs so it
cannot of itself be throttled.  However it may contribute to the
number of accumulated unexecuted tasks in the event loop and therefore
contribute to the throttling of other threads by the loop.  See the
documentation on the make-event-loop procedure for further information
about that.

Exceptions may propagate out of this procedure if they arise while
setting up (that is, before the task starts), which shouldn't happen
unless memory is exhausted.  Exceptions arising during execution of
the generator, if not caught locally, will propagate out of
await-generator!.  Exceptions thrown by 'proc', if not caught locally,
will propagate out of event-loop-run!.

This procedure is first available in version 0.9 of this library.

Here is an example of the use of await-generator!:
@example
(set-default-event-loop!) ;; if none has yet been set
(a-sync (lambda (await resume)
	  (await-generator! await resume
			    (lambda (yield)
			      (let loop ((count 0))
				(when (< count 5)
				  (yield (* 2 count))
				  (loop (1+ count)))))
			    (lambda (val)
			      (display val)
			      (newline)))))
(event-loop-run!)
@end example
@end deffn

@deffn {Scheme Procedure} await-timeout! await resume [loop] msecs thunk
This is a convenience procedure for use with an event loop, which will
run 'thunk' in the event loop thread when the timeout expires.  This
procedure calls 'await' and will return the thunk's return value.  It
is intended to be called in a waitable procedure invoked by a-sync.
The timeout is single shot only - as soon as 'thunk' has run once and
completed, the timeout will be removed from the event loop.  The
'loop' argument is optional: this procedure operates on the event loop
passed in as an argument, or if none is passed (or #f is passed), on
the default event loop.

This procedure must (like the a-sync procedure) be called in the same
thread as that in which the event loop runs.

Exceptions may propagate out of this procedure if they arise while
setting up (that is, before the first call to 'await' is made), which
shouldn't happen unless memory is exhausted.  Exceptions thrown by
'thunk', if not caught locally, will propagate out of event-loop-run!.

Here is an example of the use of event-timeout!:
@example
(set-default-event-loop!) ;; if none has yet been set
(a-sync (lambda (await resume)
	  (simple-format #t
			 "Timeout ~A\n"
			 (await-timeout! await resume
					 100
					 (lambda ()
					   "expired")))))
(event-loop-run!)
@end example
@end deffn

@deffn {Scheme Procedure} a-sync-read-watch! resume file proc [loop]
This is a convenience procedure for use with an event loop, which will
run 'proc' in the event loop thread whenever 'file' is ready for
reading, and apply 'resume' (obtained from a call to a-sync) to the
return value of 'proc'.  'file' can be a port or a file descriptor
(and if it is a file descriptor, the revealed count is not
incremented).  'proc' should take a single argument which will be set
by the event loop to 'in or 'excpt (see the documentation on
event-loop-add-read-watch! for further details).  It is intended to be
called in a waitable procedure invoked by a-sync.  The watch is
multi-shot - it is for the user to bring it to an end at the right
time by calling event-loop-remove-read-watch! in the waitable
procedure.  If 'file' is a buffered port, buffering will be taken into
account in indicating whether a read can be made without blocking (but
on a buffered port, for efficiency purposes each read operation in
response to this watch should usually exhaust the buffer by calling
drain-input or by looping on char-ready?).

This procedure is mainly intended as something from which higher-level
asynchronous file operations can be constructed, such as the
await-readline! procedure.  The 'loop' argument is optional: this
procedure operates on the event loop passed in as an argument, or if
none is passed (or #f is passed), on the default event loop

Because this procedure takes a 'resume' argument derived from the
a-sync procedure, it must (like the a-sync procedure) in practice be
called in the same thread as that in which the event loop runs.

This procedure should not throw an exception unless memory is
exhausted.  If 'proc' throws, say because of port errors, and the
exception is not caught locally, it will propagate out of
event-loop-run!.

As an example of how to use a-sync-read-watch!, here is the
implementation of await-getline!:
@example
(define await-getline!
   (case-lambda
    ((await resume port)
     (await-getline! await resume #f port))
    ((await resume loop port)
     (let ()
       (define chunk-size 128)
       (define text (make-bytevector chunk-size))
       (define text-len 0)
       (define (append-byte! u8)
	 (when (= text-len (bytevector-length text))
	   (let ((tmp text))
	     (set! text (make-bytevector (+ text-len chunk-size)))
	     (bytevector-copy! tmp 0 text 0 text-len)))
	 (bytevector-u8-set! text text-len u8)
	 (set! text-len (1+ text-len)))
       (define (make-outstring)
	 (let ((encoding (or (port-encoding port)
			     (fluid-ref %default-port-encoding)
			     "ISO-8859-1"))
	       (conversion-strategy (port-conversion-strategy port))
	       (out-bv (make-bytevector text-len)))
	   (bytevector-copy! text 0 out-bv 0 text-len)
	   (iconv:bytevector->string out-bv encoding conversion-strategy)))
       (a-sync-read-watch! resume
			   port
			   (lambda (status)
			     (if (eq? status 'excpt)
				 #f
				 (let next ()
				   (let ((u8
					  (catch 'system-error
					    (lambda ()
					      (get-u8 port))
					    (lambda args
					      (if (or (= EAGAIN (system-error-errno args))
						      (and (defined? 'EWOULDBLOCK) 
							   (= EWOULDBLOCK (system-error-errno args))))
						  'more
						  (apply throw args))))))
				     (cond
				      ((eq? u8 'more)
				       'more)
				      ((eof-object? u8)
				       (if (= text-len 0)
					   u8
					   (make-outstring)))
				      ((= u8 (char->integer #\return))
				       (if (char-ready? port)
					   (next)
					   'more))
				      ((= u8 (char->integer #\newline))
				       (make-outstring))
				      (else
				       (append-byte! u8)
				       (if (char-ready? port)
					   (next)
					   'more)))))))
			   loop))
     (let next ((res (await)))
       (if (eq? res 'more)
	   (next (await))
	   (begin
	     (event-loop-remove-read-watch! port loop)
	     res))))))
@end example
@end deffn

@deffn {Scheme Procedure} await-getline! await resume [loop] port
This is a convenience procedure for use with an event loop, which will
start a read watch on 'port' for a line of input.  It calls 'await'
while waiting for input and will return the line of text received
(without the terminating '\n' character).  The event loop will not be
blocked by this procedure even if only individual characters are
available at any one time.  It is intended to be called in a waitable
procedure invoked by a-sync, and this procedure is implemented using
a-sync-read-watch!.  If an exceptional condition ('excpt) is
encountered, #f will be returned.  If an end-of-file object is
encountered which terminates a line of text, a string containing the
line of text will be returned (and from version 0.3, if an end-of-file
object is encountered without any text, the end-of-file object is
returned rather than an empty string).  The 'loop' argument is
optional: this procedure operates on the event loop passed in as an
argument, or if none is passed (or #f is passed), on the default event
loop.

This procedure must (like the a-sync procedure) be called in the same
thread as that in which the event loop runs.

Exceptions may propagate out of this procedure if they arise while
setting up (that is, before the first call to 'await' is made), which
shouldn't happen unless memory is exhausted.  Subsequent exceptions
(say, because of port or conversion errors) will propagate out of
event-loop-run!.

From version 0.6, the bytes comprising the input text will be
converted to their string representation using the encoding of 'port'
if a port encoding has been set, or otherwise using the program's
default port encoding, or if neither has been set using iso-8859-1
(Latin-1).  Exceptions from conversion errors will, as mentioned,
propagate out of event-loop-run!.  Conversion errors should not arise
with iso-8859-1 encoding, although the string may not necessarily have
the desired meaning for the program concerned if the input encoding is
in fact different.  From version 0.7, this procedure uses the
conversion strategy for 'port' (which defaults at program start-up to
'substitute); version 0.6 instead always used a conversion strategy of
'error if encountering unconvertible characters).

From version 0.6, this procedure may be used with an end-of-line
representation of either a line-feed (\n) or a carriage-return and
line-feed (\r\n) combination, as from version 0.6 any carriage return
byte will be discarded (this did not occur with earlier versions).

Here is an example of the use of await-getline!:
@example
(set-default-event-loop!) ;; if none has yet been set
(a-sync (lambda (await resume)
	  (display "Enter a line of text at the keyboard\n")
	  (simple-format #t
			 "The line was: ~A\n"
			 (await-getline! await resume
					 (open "/dev/tty" O_RDONLY)))))
(event-loop-run!)
@end example
@end deffn

@deffn {Scheme Procedure} await-geteveryline! await resume [loop] port proc
This is a convenience procedure for use with an event loop, which will
start a read watch on 'port' for lines of input.  It calls 'await'
while waiting for input and will apply 'proc' to every complete line
of text received (without the terminating '\n' character).  'proc'
should be a procedure taking a string as its only argument.

The event loop will not be blocked by this procedure even if only
individual characters are available at any one time.  It is intended
to be called in a waitable procedure invoked by a-sync, and this
procedure is implemented using a-sync-read-watch!.  Unlike the
await-getline! procedure, the watch will continue after a line of text
has been received in order to receive further lines.  The watch will
not end until end-of-file or an exceptional condition ('excpt) is
reached.  In the event of that happening, this procedure will end and
return an end-of-file object or #f respectively.

The 'loop' argument is optional: this procedure operates on the event
loop passed in as an argument, or if none is passed (or #f is passed),
on the default event loop.

This procedure must (like the a-sync procedure) be called in the same
thread as that in which the event loop runs.

Exceptions may propagate out of this procedure if they arise while
setting up (that is, before the first call to 'await' is made), which
shouldn't happen unless memory is exhausted.  Subsequent exceptions
(say, because of port or conversion errors) will propagate out of
event-loop-run!.  Exceptions thrown by 'proc', if not caught locally,
will also propagate out of event-loop-run!.

This procedure is available from version 0.3.  From version 0.6, the
bytes comprising the input text will be converted to their string
representation using the encoding of 'port' if a port encoding has
been set, or otherwise using the program's default port encoding, or
if neither has been set using iso-8859-1 (Latin-1).  Exceptions from
conversion errors will, as mentioned, propagate out of
event-loop-run!.  Conversion errors should not arise with iso-8859-1
encoding, although strings may not necessarily have the desired
meaning for the program concerned if the input encoding is in fact
different.  From version 0.7, this procedure uses the conversion
strategy for 'port' (which defaults at program start-up to
'substitute); version 0.6 instead always used a conversion strategy of
'error if encountering unconvertible characters).

From version 0.6, this procedure may be used with an end-of-line
representation of either a line-feed (\n) or a carriage-return and
line-feed (\r\n) combination, as from version 0.6 any carriage return
byte will be discarded (this did not occur with earlier versions).

Here is an example of the use of await-geteveryline! (because the
keyboard has no end-of-file, use Ctrl-C to exit this code snippet):
@example
(set-default-event-loop!) ;; if none has yet been set
(a-sync (lambda (await resume)
	  (display "Enter lines of text at the keyboard, ^C to finish\n")
	  (let ((port (open "/dev/tty" O_RDONLY)))
	    (await-geteveryline! await resume
				 port
				 (lambda (line)
				   (simple-format #t
						  "The line was: ~A\n"
						  line))))))
(event-loop-run!)
@end example
@end deffn

@deffn {Scheme Procedure} await-getsomelines! await resume [loop] port proc
This is a convenience procedure for use with an event loop, which does
the same as await-geteveryline!, except that it provides a second
argument to 'proc', namely an escape continuation which can be invoked
by 'proc' to cause the procedure to return before end-of-file is
reached.  Behavior is identical to await-geteveryline! if the
continuation is not invoked.

This procedure will start a read watch on 'port' for lines of input.
It calls 'await' while waiting for input and will apply 'proc' to any
complete line of text received (without the terminating '\n'
character).  'proc' should be a procedure taking two arguments, a
string as the first argument containing the line of text read, and an
escape continuation as its second.

The event loop will not be blocked by this procedure even if only
individual characters are available at any one time.  It is intended
to be called in a waitable procedure invoked by a-sync.  This
procedure is implemented using a-sync-read-watch!.  The watch will not
end until end-of-file or an exceptional condition ('excpt) is reached,
which would cause this procedure to end and return an end-of-file
object or #f respectively, or until the escape continuation is
invoked, in which case the value passed to the escape continuation
will be returned.

The 'loop' argument is optional: this procedure operates on the event
loop passed in as an argument, or if none is passed (or #f is passed),
on the default event loop.

This procedure must (like the a-sync procedure) be called in the same
thread as that in which the event loop runs.

Exceptions may propagate out of this procedure if they arise while
setting up (that is, before the first call to 'await' is made), which
shouldn't happen unless memory is exhausted.  Subsequent exceptions
(say, because of port or conversion errors) will propagate out of
event-loop-run!.  Exceptions thrown by 'proc', if not caught locally,
will also propagate out of event-loop-run!.

This procedure is available from version 0.4.  From version 0.6, the
bytes comprising the input text will be converted to their string
representation using the encoding of 'port' if a port encoding has
been set, or otherwise using the program's default port encoding, or
if neither has been set using iso-8859-1 (Latin-1).  Exceptions from
conversion errors will, as mentioned, propagate out of
event-loop-run!.  Conversion errors should not arise with iso-8859-1
encoding, although strings may not necessarily have the desired
meaning for the program concerned if the input encoding is in fact
different.  From version 0.7, this procedure uses the conversion
strategy for 'port' (which defaults at program start-up to
'substitute); version 0.6 instead always used a conversion strategy of
'error if encountering unconvertible characters).

From version 0.6, this procedure may be used with an end-of-line
representation of either a line-feed (\n) or a carriage-return and
line-feed (\r\n) combination, as from version 0.6 any carriage return
byte will be discarded (this did not occur with earlier versions).

Here is an example of the use of await-getsomelines!:
@example
(set-default-event-loop!) ;; if none has yet been set
(a-sync (lambda (await resume)
	  (display "Enter lines of text at the keyboard, enter an empty line to finish\n")
	  (let ((port (open "/dev/tty" O_RDONLY)))
	    (await-getsomelines! await resume
				 port
				 (lambda (line k)
                                   (when (string=? line "")
					 (k #f))
				   (simple-format #t
						  "The line was: ~A\n"
						  line))))))
(event-loop-run!)
@end example
@end deffn

@deffn {Scheme Procedure} a-sync-write-watch! resume file proc [loop]
This is a convenience procedure for use with an event loop, which will
run 'proc' in the event loop thread whenever 'file' is ready for
writing, and apply 'resume' (obtained from a call to a-sync) to the
return value of 'proc'.  'file' can be a port or a file descriptor
(and if it is a file descriptor, the revealed count is not
incremented).  'proc' should take a single argument which will be set
by the event loop to 'out or 'excpt (see the documentation on
event-loop-add-write-watch! for further details).  It is intended to
be called in a waitable procedure invoked by a-sync.  The watch is
multi-shot - it is for the user to bring it to an end at the right
time by calling event-loop-remove-write-watch! in the waitable
procedure.  This procedure is mainly intended as something from which
higher-level asynchronous file operations can be constructed.  The
'loop' argument is optional: this procedure operates on the event loop
passed in as an argument, or if none is passed (or #f is passed), on
the default event loop

The documentation on the event-loop-add-write-watch! procedure
explains why this procedure generally works best with an unbuffered
port.

Because this procedure takes a 'resume' argument derived from the
a-sync procedure, it must (like the a-sync procedure) in practice be
called in the same thread as that in which the event loop runs.

This procedure should not throw an exception unless memory is
exhausted.  If 'proc' throws, say because of port errors, and the
exception is not caught locally, it will propagate out of
event-loop-run!.

As an example of how to use a-sync-write-watch!, here is the
implementation of await-put-bytevector!:
@example
(define await-put-bytevector! 
  (case-lambda
    ((await resume port bv) (await-put-bytevector! await resume #f port bv))
    ((await resume loop port bv)
     (define length (bytevector-length bv))
     (define index 0)
     (_throw-exception-if-regular-file (fileno port))

     (let ((fd (port->fdes port)))
       (a-sync-write-watch! resume
			    fd
			    (lambda (status)
			      (catch #t
				(lambda ()
				  (if (eq? status 'excpt)
				      #f
				      (begin
					(set! index (+ index (c-write fd
								      bv
								      index
								      (- length index))))
					(if (< index length)
					    'more
					    #t))))
				(lambda args
				  (release-port-handle port)
				  (apply throw args))))
			    loop)
       (let next ((res (await)))
	 (if (eq? res 'more)
	     (next (await))
	     (begin
	       (event-loop-remove-write-watch! fd loop)
	       (release-port-handle port)
	       res)))))))
@end example
@end deffn

@deffn {Scheme Procedure} await-put-bytevector! await resume [loop] port bv
This is a convenience procedure for use in an event loop, which will
start a write watch on 'port' for writing the contents of a bytevector
'bv' to the port.  It calls 'await' while waiting for output to become
available.  The event loop will not be blocked by this procedure even
if only individual bytes can be written at any one time (although if
'port' references a socket, it should be non-blocking for this to be
guaranteed).  It is intended to be called in a waitable procedure
invoked by a-sync, and this procedure is implemented using
a-sync-write-watch!.  If an exceptional condition ('excpt) is
encountered, #f will be returned, otherwise #t will be returned (but
an exceptional condition should never be encountered on an output
port).  The 'loop' argument is optional: this procedure operates on
the event loop passed in as an argument, or if none is passed (or #f
is passed), on the default event loop.

A port can be made non-blocking with this:

@example
(fcntl [port] F_SETFL (logior O_NONBLOCK
                      (fcntl [port] F_GETFL)))
@end example

For reasons of efficiency, this procedure by-passes the port's output
buffer and sends the output to the underlying file descriptor
directly.  This means that it is most convenient for use with
unbuffered ports.  However, where the port must be an input-output
port (say it represents a socket) and it is desirable that the input
is buffered (as it usually is), this procedure can be used with a port
with buffered output.  However, if that is done and the port has
previously been used for output by a procedure other than c-write or
an await-put* procedure, then it should be flushed before this
procedure is called.

This procedure will throw a 'c-write-error exception if passed a
regular file with a file position pointer: there should be no need to
use this procedure with regular files, because they cannot normally
block on write and are always signalled as ready.

This procedure must (like the a-sync procedure) be called in the same
thread as that in which the event loop runs.

Exceptions may propagate out of this procedure if they arise while
setting up (that is, before the first call to 'await' is made), which
shouldn't happen unless memory is exhausted or a regular file is
passed to this procedure.  Subsequent exceptions (say, because of port
errors) will propagate out of event-loop-run!.

This procedure is first available in version 0.11 of this library.

An example of the use of await-put-string!, which is implemented using
this procedure, can be found in the example-socket.scm file in the
docs directory.
@end deffn

@deffn {Scheme Procedure} await-put-string! await resume [loop] port text
This is a convenience procedure for use in an event loop, which will
start a write watch on 'port' for writing a string to the port.  It
calls 'await' while waiting for output to become available.  The event
loop will not be blocked by this procedure even if only individual
characters or part characters can be written at any one time (although
if 'port' references a socket, it should be non-blocking for this to
be guaranteed).  It is intended to be called in a waitable procedure
invoked by a-sync, and this procedure is implemented using
await-put-bytevector!.  If an exceptional condition ('excpt) is
encountered, #f will be returned, otherwise #t will be returned (but
an exceptional condition should never be encountered on an output
port).  The 'loop' argument is optional: this procedure operates on
the event loop passed in as an argument, or if none is passed (or #f
is passed), on the default event loop.

A port can be made non-blocking with this:

@example
(fcntl [port] F_SETFL (logior O_NONBLOCK
                      (fcntl [port] F_GETFL)))
@end example

For reasons of efficiency, this procedure by-passes the port's output
buffer and sends the output to the underlying file descriptor
directly.  This means that it is most convenient for use with
unbuffered ports.  However, where the port must be an input-output
port (say it represents a socket) and it is desirable that the input
is buffered (as it usually is), this procedure can be used with a port
with buffered output.  However, if that is done and the port has
previously been used for output by a procedure other than c-write or
an await-put* procedure, then it should be flushed before this
procedure is called.

This procedure will throw a 'c-write-error exception if passed a
regular file with a file position pointer: there should be no need to
use this procedure with regular files, because they cannot normally
block on write and are always signalled as ready.

This procedure must (like the a-sync procedure) be called in the same
thread as that in which the event loop runs.

Exceptions may propagate out of this procedure if they arise while
setting up (that is, before the first call to 'await' is made), which
shouldn't happen unless memory is exhausted, a conversion error is
encountered or a regular file is passed to this procedure.  Subsequent
exceptions (say, because of port errors) will propagate out of
event-loop-run!.

The bytes to be sent will be converted from the passed in string
representation using the encoding of 'port' if a port encoding has
been set, or otherwise using the program's default port encoding, or
if neither has been set using iso-8859-1 (Latin-1).  Exceptions from
conversion errors will propagate out of this procedure when setting up
if conversion fails and a conversion strategy of 'error is in effect.
This procedure uses the conversion strategy for 'port' (which defaults
at program start-up to 'substitute).

If CR-LF line endings are to be written when outputting the string,
the '\r' character (as well as the '\n' character) must be embedded in
the string.

This procedure is first available in version 0.10 of this library.

An example of the use of this procedure can be found in the
example-socket.scm file in the docs directory.
@end deffn

@deffn {Scheme Procedure} c-write fd bv begin count
This procedure is used by await-put-bytevector! (and so by
await-put-string!) and is exported by event-loop.scm so that it can be
used by other asynchronous procedures.  It makes a block write
directly to output, bypassing any output buffers, using unix write.
It is intended for use with asynchronous procedures which write blocks
of data, to enable them to do so efficiently.

This procedure provides a 'begin' parameter indicating the start of
the sequence of bytes to be written, as an index.  'fd' is the file
descriptor of the device to be written to, and it should be
non-blocking.  'bv' is a bytevector containing the bytes to be
written.  'count' is the maximum number of bytes to be written.
Because this procedure is intended for use with non-blocking ports, it
may write less than 'count' bytes: only the number of bytes available
to the device to be written to will be written at any one time.  The
sum of 'begin' and 'count' must not be more than the length of the
bytevector.  The use of a separate 'begin' index enables the same
bytevector to be written from repeatedly until all of it has been
sent.

Provided 'fd' is non-blocking, this procedure returns immediately with
the number of bytes written (so 0 is returned if the file descriptor
is not available for writing because the device is full).  On a write
error other than EAGAIN, EWOULDBLOCK or EINTR, a 'c-write-error
exception is thrown and errno is given as an argument to the exception
handler.  EINTR is handled internally and is not an error.

This procedure is first available in version 0.11 of this library.
@end deffn

The (a-sync event-loop) module also loads the @ref{monotonic
time,,(a-sync monotonic-time)} module.
